# Twitter Client through SB6
#
# Using BOT twitter (or tw) <msg> to send a tweet
# Retweet: BOT twitter (or tw) retweet (or rt) <name> <msg> to retweet a message
# Direct Message: BOT twitter (or tw) dm <name> <msg> to direct message one of your followers
# Friends: BOT twitter (or tw) friends to retrieve a friend's timeline
# Replies: BOT twitter (or tw) replies to retrieve your replies (@yourname) timeline
# Follow: BOT twitter (or tw) follow <name> to follow a user
# Unfollow: BOT twitter (or tw) unfollow <name> to unfollow a user
#
# It is required to place your bot in a channel dedicated to twitter as to not disrupt another channel's chatter
#
# TODO:
#   * Store twitter username and password to bot user data file via /msg bot ONLY (security reasons) (DONE - Thanks Mai!)
#   * Work on handling the different retrieval methods (DONE)
#   * Write the help on the commands (DONE)
#   * Better handle (re)tweets and direct messages greater than 140 characters (DONE)
#   * Implement oAuth.
#   * Implement URL shorteners of is.gd, moourl.com, bit.ly, or cli.gs
#
# Change Log:
# Please refer to http://github.com/demonicpagan/Stormbot-TCL-Twitter-Module for changes made

SB:command add TWITTER 1 -none TW
SB:register variable global TWITTER:*
sbdset SB:author "Dustin Shea (demonicpagan@gmail.com)"

# Make sure the require packages are installed
empty package_failed
foreach package [list base64 json http ncgi sha256] {
	set error [catch {package require $package} shit]
	if $error {lappend package_failed $package}
}
sbdset TWITTER:PACKAGE_FAIL $package_failed
unset package_failed

proc SB:proc_twitter {nick host handle chan arg} {
	set package_failed [sbdget TWITTER:PACKAGE_FAIL]
	SB:setvariables

	set disp [sbdget TWITTER:DISP]
	if {$disp == ""} { set disp 0 }

	# Set $DCCOKAY to 0 (only allow /MSG commands), or 1 (/MSG & .DCC are okay).
	set dccokay 0

	# Help information
	if [string eq -nocase HELP $1] {
		printh $nick "\[TWITTER\]:"
		printh $nick "This command will essentially turn your Stormbot eggdrop bot into a twitter client."
		printh $nick "It is best to when using this command, place your bot in its own channel."
		printh $nick ""
		if [string eq ALL $u2] {
			if [SB:checklevel [sbd:get USERLEVEL:BOTOWNER] $handle] {
				printh $nick "\002 Storing your Twitter credentials\002"
				printh $nick "/msg $::botnick TWITTER SETKEY <consumer key>"
				printh $nick "/msg $::botnick TWITTER SETSECRET <consumer secret>"
				printh $nick "These are obtained by registering the bot as an app at: https://twitter.com/apps"
				printh $nick ""
			} else {
				printh $nick "\002Client Option\002"
					printh $nick "Syntax: $::botnick TWITTER RESTRICT <channel> (Only use twitter in this channel, must have 1000 access on the bot to set) - MUST BE SET!."
					printh $nick "Syntax: $::botnick TWITTER DISPLAY <off/on> (Display the readable name of twitter user)"
					printh $nick "Syntax: $::botnick TWITTER STATUS (Display the rate limit status of your account)"
					printh $nick "Syntax: $::botnick TWITTER PROFILE SET (-name|-url|-location|-description) (Sets your profile information)"
					printh $nick "Syntax: $::botnick TWITTER PROFILE VIEW <screen name> (View a users profile)"
					printh $nick "Syntax: $::botnick TWITTER SEARCH <search query> (Search for a profile)"
					printh $nick "Syntax: $::botnick TWITTER SHORTEN <number> (Set the length of url's that will be shortened. 12-20 recommended)"
					printh $nick "Syntax: $::botnick TWITTER SHORTENER <option> (0=is.gd, 1=moourl.com, 2=bit.ly, 3=cli.gs)"
					printh $nick "Syntax: $::botnick TWITTER BITLYUN (Your bit.ly account username)"
					printh $nick "Syntax: $::botnick TWITTER BITLYAPI (Your bit.ly account API key)"
				printh $nick ""
				printh $nick "\002Client commands\002"
					printh $nick "Syntax: $::botnick TWITTER <message text> (Send a status update to twitter - 140 Char limit)"
					printh $nick "Syntax: $::botnick TWITTER FOLLOW <name> (Follow a twitter user - Can only be used in Twitter channel)"
					printh $nick "Syntax: $::botnick TWITTER UNFOLLOW <name> (Unfollow a twitter user)"
					printh $nick "Syntax: $::botnick TWITTER FRIENDS (Displays your public timeline that includes your friends' tweets)"
					printh $nick "Syntax: $::botnick TWITTER MENTIONS (Displays messages directed at you.)"
					printh $nick "Syntax: $::botnick TWITTER RETWEET <name> <msg> (Retweet a message that you found interesting - 140 Char limit)"
					printh $nick "Syntax: $::botnick TWITTER DELETE <msg id #> (Delete a tweet YOU sent)"
					printh $nick "Syntax: $::botnick TWITTER DIRECT SEND <name> <msg> (Send a direct message to a user - 140 Char limit)"
					printh $nick "Syntax: $::botnick TWITTER DIRECT LIST (lists your direct messages and their id number)"
					printh $nick "Syntax: $::botnick TWITTER DIRECT DEL <msg id #> (deletes a direct message)"
					printh $nick "Syntax: $::botnick TWITTER BLOCK ADD <screen name> (Add someone to the block list)"
					printh $nick "Syntax: $::botnick TWITTER BLOCK DEL <screen name> (Remove someone from the block list)"
					printh $nick "Syntax: $::botnick TWITTER BLOCK CHECK <screen name> (Check to see if someone is on your block list)"
					printh $nick "Syntax: $::botnick TWITTER BLOCK LIST (List your blocked people)"
					printh $nick "Syntax: $::botnick TWITTER TRENDS (Displays the current top 10 trending topics with the search URL)"
					printh $nick "Syntax: $::botnick TWITTER FAVORITES (Displays your favorited tweets)"
			}
		} else {
			printh $nick "To see all available options, use: $::botnick TWITTER HELP ALL"
		}

		printh $nick ""
		printh $nick "NOTICE: If your tweet, direct message, retweet contains a URL and you go over the 140 character limit, use a url shortener"
		printh $nick "like tinyurl.com, bit.ly, moourl.com, is.gd, or any other url shortener that you know of and resubmit your tweet."

		if [notempty package_failed] {
			printh $nick ""
			printh $nick "I'm sorry, but I can't execute the TWITTER command: I'm missing some code packages ([ajl $package_failed]). Please have my owner install these packages so I can run this command."
		}
		return 0
	}


	if [notempty package_failed] {print $nick "I'm sorry, but I can't execute the TWITTER command: I'm missing some code packages ([ajl $package_failed]). Please have my owner install these packages so I can run this command."; return 0}
	switch -glob -- $l1 {

		ky - key - consumerkey - setky - setkey - setconsumerkey {
			if $dccokay {
				if [sbd:equal -nocase @LAST_TRIGGER PUB] {printh $nick "You may not use this command in channel, for security purposes. Use either /MSG or .DCC to use this command."; return 0}
			} else {
				if ![sbd:equal -nocase @LAST_TRIGGER MSG] {printh $nick "You may only use this command in /MSG format for security purposes."; return 0}
			}

			sbdset TWITTER:CONSUMER_KEY $2
			SB:botdatafile write
			print $nick "Your TWITTER API Consumer Key has been saved."
			return 0
		}

		secret - consumersecret - setsecret - setconsumersecret {
			if $dccokay {
				if [sbd:equal -nocase @LAST_TRIGGER PUB] {printh $nick "You may not use this command in channel, for security purposes. Use either /MSG or .DCC to use this command."; return 0}
			} else {
				if ![sbd:equal -nocase @LAST_TRIGGER MSG] {printh $nick "You may only use this command in /MSG format for security purposes."; return 0}
			}

			sbdset TWITTER:CONSUMER_SECRET $2
			SB:botdatafile write
			print $nick "Your TWITTER API Consumer Secret has been saved."
			return 0
		}

		dis - disp - display {
			# Display the readable format of a twitter user by their screen name
			set offon [nozero [l0 $disp]]
			if [isempty 2] {print $nick "Current TWITTER USER DISPLAY status: [offon $offon]"; return 0}
			set 2 [string is true $2]

			sbdset TWITTER:DISP $2
			SB:botdatafile write
			print $nick "Twitter user display is now: [stu [offon $2]]"
			return 0
		}

		lc - lock* - chan - rest* {
			set editaccess 1000
			if ![SB:checkaccess $editaccess $handle $chan] {printh $nick "You are not permitted to edit this setting."; return 0}
			set twhome [sbdget TWITTER:HOME]
			set thome $j2

			if [string eq "" $2] {
				if [isempty twhome] {
					print $nick "TWITTER command channel has not been set, please set one."; return 0
				} else {
					print $nick "Current TWITTER command channel: ${twhome}"; return 0
				}
			}

			if {[lsearch -exact [list OFF NONE CLEAR] $ju2] > -1} {
				sbdset TWITTER:HOME
				SB:botdatafile write
				print $nick "TWITTER command channel setting has been cleared."
				return 0
			}

			if {![validchan $thome] && ![isempty twhome]} {print $nick "${thome} is not currently a channel I reside on."; return 0}
			if {[stl $thome] == [stl $twhome]} {printh $nick "The TWITTER command channel is already set to: ${twhome}"; return 0}

			sbdset TWITTER:HOME $thome
			SB:botdatafile write
			printh $nick "Setting the TWITTER command channel to ${thome}"
			return 0
		}

		shrtn - shorten {
			# URLs/Links have to be greater than this number to be reduced by the shortner setting.
			set twhome [sbdget TWITTER:HOME]
			if [isempty twhome] {print $nick "You don't have a command channel set, you must set one to use this command."; return 0}
			if {[stl $chan] != [stl $twhome]} {print $nick "You cannot use this command in this channel, commands must be directed to ${twhome}"; return 0}

			setdata $handle TWSHORTEN $2
			save
			print $nick "URLs/Links will now be shortened if greater than $2 characters."
			return 0
		}

		shrtnr - shortener {
			#Choice of URL/Link shortener
			# 0=is.gd, 1=moourl.com, 2=bit.ly, 3=cli.gs
			set twhome [sbdget TWITTER:HOME]
			if [isempty twhome] {print $nick "You don't have a command channel set, you must set one to use this command."; return 0}
			if {[stl $chan] != [stl $twhome]} {print $nick "You cannot use this command in this channel, commands must be directed to ${twhome}"; return 0}

			setdata $handle TWSHORTENER $2
			save

			if {$2 == 0} {print $nick "Your URL/Link shortener has been set to http://is.gd"; return 0}
			if {$2 == 1} {print $nick "Your URL/Link shortener has been set to http://moourl.com"; return 0}
			if {$2 == 2} {print $nick "Your URL/Link shortener has been set to http://bit.ly. Please set your bit.ly username and API key."; return 0}
			if {$2 == 3} {print $nick "Your URL/Link shortener has been set to http://cli.gs"; return 0}

			return 0
		}

		bun - bitlyun - bitlyusername {
			# User's bit.ly account username
			if $dccokay {
				if [sbd:equal -nocase @LAST_TRIGGER PUB] {printh $nick "You may not use this command in channel, for security purposes. Use either /MSG or .DCC to use this command."; return 0}
			} else {
				if ![sbd:equal -nocase @LAST_TRIGGER MSG] {printh $nick "You may only use this command in /MSG format for security purposes."; return 0}
			}

			setdata $handle BITLY-USERNAME $2
			save
			print $nick "Your bit.ly username has been saved."
			return 0
		}

		bapi - bitlyapi - bitlyapikey {
			# User's bit.ly account API key
			if $dccokay {
				if [sbd:equal -nocase @LAST_TRIGGER PUB] {printh $nick "You may not use this command in channel, for security purposes. Use either /MSG or .DCC to use this command."; return 0}
			} else {
				if ![sbd:equal -nocase @LAST_TRIGGER MSG] {printh $nick "You may only use this command in /MSG format for security purposes."; return 0}
			}

			setdata $handle BITLY-APIKEY $2
			save
			print $nick "Your bit.ly API Key has been saved."
			return 0
		}

		rate - ratelimit - stat - stats - status {
			set twhome [sbdget TWITTER:HOME]
			if [isempty twhome] {print $nick "You don't have a command channel set, you must set one to use this command."; return 0}
			if {[stl $chan] != [stl $twhome]} {print $nick "You cannot use this command in this channel, commands must be directed to ${twhome}"; return 0}

			# Use twitter:senddata process ($handle $mode(opt.) $url $text(being sent) $query(if being used - the variable) $extra(optional variable))
			set www [twitter:senddata $handle ratelimit account/rate_limit_status.json "" "" ""]
			set data [l1 $www]
			set status [list [json::json2dict $data]]

			foreach stat $status {
				set remaining_hits [dict get $stat remaining_hits ]
				set hourly_limit [dict get $stat hourly_limit]
				set reset_time_sec [dict get $stat reset_time_in_seconds]

				if {$remaining_hits > 0} {
					print $nick "Status: All good, $remaining_hits/$hourly_limit requests left, Resets: [clock format $reset_time_sec -format "%l:%M %p"]"
					return 0
				} else {
					print $nick "Status: Rate limit exceeded, $remaining_hits/$hourly_limit requests left, Resets: [clock format $reset_time_sec -format "%l:%M %p"]"
					return 0
				}
			}
			return 0
		}

		profile {
			set twhome [sbdget TWITTER:HOME]
			if [isempty twhome] {print $nick "You don't have a command channel set, you must set one to use this command."; return 0}
			if {[stl $chan] != [stl $twhome]} {print $nick "You cannot use this command in this channel, commands must be directed to ${twhome}"; return 0}

			set arg $2e

			# This will reset all the MISC variables, but will have parsed the flags
			checkflags5 flags arg $arg [list -name -url -location -description] 1 1

			switch -exact -- $l0 {
				set {
					if [isvalidflag $flags -name] {
						# Update the name on your profile
						# Use twitter:senddata process ($handle $mode(opt.) $url $text(being sent) $query(if being used - the variable) $extra(optional variable))
						set www [twitter:senddata $handle "" account/update_profile.json "" $j1e name]

						# Process 400 & Unknown Errors
						set ncode [l0 $www]
						set code [l2 $www]
						set data [l1 $www]
						if [string eq -1 $ncode] { error "Unknown error: $data" }
						if [string eq 400 $ncode] {printh $nick "Unable to update your name, please try again. :: $code"; return 0}

						print $nick "Your name has now been set to $j0e"
						return 0
					}

					if [isvalidflag $flags -url] {
						# Update the url on your profile
						# Use twitter:senddata process ($handle $mode(opt.) $url $text(being sent) $query(if being used - the variable) $extra(optional variable))
						set www [twitter:senddata $handle "" account/update_profile.json "" $j1e url]

						# Process 400 & Unknown Errors
						set ncode [l0 $www]
						set code [l2 $www]
						set data [l1 $www]
						if [string eq -1 $ncode] { error "Unknown error: $data" }
						if [string eq 400 $ncode] {printh $nick "Unable to update your url, please try again. :: $code"; return 0}

						print $nick "Your url has now been set to $j0e"
						return 0
					}

					if [isvalidflag $flags -location] {
						# Update the location on your profile
						# Use twitter:senddata process ($handle $mode(opt.) $url $text(being sent) $query(if being used - the variable) $extra(optional variable))
						set www [twitter:senddata $handle "" account/update_profile.json "" $j1e location]

						# Process 400 & Unknown Errors
						set ncode [l0 $www]
						set code [l2 $www]
						set data [l1 $www]
						if [string eq -1 $ncode] { error "Unknown error: $data" }
						if [string eq 400 $ncode] {printh $nick "Unable to update your location, please try again. :: $code"; return 0}

						print $nick "Your location has now been set to $j0e"
						return 0
					}

					if [isvalidflag $flags -description] {
						# Update the description on your profile
						# Use twitter:senddata process ($handle $mode(opt.) $url $text(being sent) $query(if being used - the variable) $extra(optional variable))
						set www [twitter:senddata $handle "" account/update_profile.json "" $j1e description]

						# Process 400 & Unknown Errors
						set ncode [l0 $www]
						set code [l2 $www]
						set data [l1 $www]
						if [string eq -1 $ncode] { error "Unknown error: $data" }
						if [string eq 400 $ncode] {printh $nick "Unable to update your description, please try again. :: $code"; return 0}

						print $nick "Your description has now been set to $j0e"
						return 0
					}
					return 0
				}

				view - show {
					set name $1

					# Use twitter:senddata process ($handle $mode(opt.) $url $text(being sent) $query(if being used - the variable) $extra(optional variable))
					set www [twitter:senddata $handle "" users/show.json?screen_name=$name "" ""]

					set data [l1 $www]
					set info [list [json::json2dict $data]]

					foreach profile $info {
						set id [dict get $profile id]
						set name [dict get $profile name]
						set sname [dict get $profile screen_name]
						set location [dict get $profile location]
						set desc [dict get $profile description]
						set url [dict get $profile url]
						set follow_count [dict get $profile followers_count]
						set status [dict get $profile status]
						set ltweet [dict get $status text]

						# Format time Sat May 26 12:45:00 +0000 2007 into an integer
						# converts it to Sat, May 26, 2007 @ 12:45 pm GMT
						# Taking in consideration for 8.4 backwards compatibility
						set created [clock format [clock scan [lreplace [split [dict get $profile created_at]] 4 4] -gmt true] -format "%a, %b %d, %Y @ %r %Z"]

						set fav_count [dict get $profile favourites_count]
						set friend_count [dict get $profile friends_count]
						set tzone [dict get $profile time_zone]
					}

					# Process 400 & Unknown Errors
					set ncode [l0 $www]
					set code [l2 $www]
					set data [l1 $www]
					if [string eq -1 $ncode] { error "Unknown error: $data" }
					if [string eq 400 $ncode] {printh $nick "Unable to update your description, please try again. :: $code"; return 0}

					print $nick "\002${sname}'s Profile ($id)\002"
					print $nick "Screen Name: $sname"
					print $nick "Name: $name"
					print $nick "Location: $location"
					print $nick "Time Zone: $tzone"
					print $nick "URL: $url"
					print $nick "Description: $desc"
					print $nick "Counts - Friends: $friend_count, Followers: $follow_count, Favorites: $fav_count"
					print $nick "Last tweet: $ltweet"
					print $nick "Created: $created"
					return 0
				}
			}
			return 0
		}

		re - rt - retweet {
			# Retweet: BOT twitter (or tw) retweet (or rt) <name> <msg> to retweet a message
			set twhome [sbdget TWITTER:HOME]
			if [isempty twhome] {print $nick "You don't have a command channel set, you must set one to use this command."; return 0}
			if {[stl $chan] != [stl $twhome]} {print $nick "You cannot use this command in this channel, commands must be directed to ${twhome}"; return 0}

			set full "rt @[string trimleft $j2e @]"

			# Use twitter:senddata process ($handle $mode(opt.) $url $text(being sent) $query(if being used - the variable) $extra(optional variable))
			set www [twitter:senddata $handle retweet statuses/update.json $full "" status]

			# Process for 403 Forbidden Response error
			set ncode [l0 $www]
			if [string eq 403 $ncode] {printh $nick "You have reached your API limit. Cannot send tweet."; return 0}

			# Process for 404 Page Not Found error
			if [string eq 404 $ncode] {printh $nick "The page that is trying to be accessed cannot be found."; return 0}

			# Process 400 & Unknown Errors
			set code [l2 $www]
			set data [l1 $www]
			if [string eq -1 $ncode] { error "Unknown error: $data" }
			if [string eq 400 $ncode] {printh $nick "Couldn't send your tweet, please try again :: $code"; return 0}

			return 0
		}

		dm - direct {
			switch -glob -- $l2 {
				send {
					# Direct Message: BOT twitter (or tw) dm send <name> <msg> to direct message one of your followers
					set twhome [sbdget TWITTER:HOME]
					if [isempty twhome] {print $nick "You don't have a command channel set, you must set one to use this command."; return 0}
					if {[stl $chan] != [stl $twhome]} {print $nick "You cannot use this command in this channel, commands must be directed to ${twhome}"; return 0}

					set text $j4e

					# Use twitter:senddata process ($handle $mode(opt.) $url $text(being sent) $query(if being used - the variable) $extra(optional variable) $dmto(opt.))
					set www [twitter:senddata $handle direct direct_messages/new.json $text "" [list text user] $3]

					# Process for 403 Forbidden Response error
					set ncode [l0 $www]
					if [string eq 403 $ncode] {printh $nick "You have reached your API limit. Cannot send direct message."; return 0}

					# Process for 404 Page Not Found error
					if [string eq 404 $ncode] {printh $nick "The page that is trying to be accessed cannot be found."; return 0}

					# Process 400 & Unknown Errors
					set code [l2 $www]
					set data [l1 $www]
					if [string eq -1 $ncode] { error "Unknown error: $data" }
					if [string eq 400 $ncode] {printh $nick "Couldn't send your direct message, please try again :: $code"; return 0}

					return 0
				}

				lst - list {
					# List your direct messages
					set twhome [sbdget TWITTER:HOME]
					if [isempty twhome] {print $nick "You don't have a command channel set, you must set one to use this command."; return 0}
					if {[stl $chan] != [stl $twhome]} {print $nick "You cannot use this command in this channel, commands must be directed to ${twhome}"; return 0}

					# Use twitter:senddata process ($handle $mode(opt.) $url $text(being sent) $query(if being used - the variable) $extra(optional variable) $dmto(opt.))
					set www [twitter:senddata $handle "" direct_messages.json "" ""]

					# Process for 403 Forbidden Response error
					set ncode [l0 $www]
					if [string eq 403 $ncode] {printh $nick "You have reached your API limit. Cannot view your direct messages."; return 0}

					# Process for 404 Page Not Found error
					if [string eq 404 $ncode] {printh $nick "The page that is trying to be accessed cannot be found."; return 0}

					# Process 400 & Unknown Errors
					set code [l2 $www]
					set data [l1 $www]
					if [string eq -1 $ncode] { error "Unknown error: $data" }
					if [string eq 400 $ncode] {printh $nick "Couldn't retrieve your direct message, please try again :: $code"; return 0}

					# Retrieve direct messages
					set msgs [lreverse [json::json2dict $data]]
					set x 0
					foreach msg $msgs {
						incr x
						set id [dict get $msg id]
						set text [dict get $msg text]
                              set sent [formattime [twitter:converttime [dict get $msg created_at]] $handle]
						set senderinfo [dict get $msg sender]
						set sender [dict get $senderinfo screen_name]
						set name [dict get $senderinfo name]

						print $nick "$x. $name ($sender) sent: $text ($sent)(Msg ID: $id)"
					}

					return 0
				}

				"-" - del* {
					# BOT twitter (or tw) dm del <msg id #> Delete Direct messages
					# http://twitter.com/direct_messages/destroy/id.format - id = msg number (use list to get number)
					set twhome [sbdget TWITTER:HOME]
					if [isempty twhome] {print $nick "You don't have a command channel set, you must set one to use this command."; return 0}
					if {[stl $chan] != [stl $twhome]} {print $nick "You cannot use this command in this channel, commands must be directed to ${twhome}"; return 0}

					set id $3

					# Use twitter:senddata process ($handle $mode(opt.) $url $text(being sent) $query(if being used - the variable) $extra(optional variable) $dmto(opt.))
					set www [twitter:senddata $handle "" direct_messages/destroy/$id.json "" $id id]

					# Process for 404 Page Not Found error
					set ncode [l0 $www]
					if [string eq 404 $ncode] {printh $nick "The page that is trying to be accessed cannot be found."; return 0}

					# Process 400 & Unknown Errors
					set code [l2 $www]
					set data [l1 $www]
					if [string eq -1 $ncode] { error "Unknown error: $data" }
					if [string eq 400 $ncode] {printh $nick "Couldn't retrieve your direct messages, please try again :: $code"; return 0}

					# Retrieve message for deletion
					set msg [list [json::json2dict $data]]
					foreach a $msg {
						set sendinfo [dict get $a sender]
						set sender [dict get $sendinfo name]
						set id [dict get $a id]
						set text [dict get $a text]

						print $nick "Deleted msg: $id \"$text\" sent from $sender"
					}

					return 0
				}
			}
			return 0
		}

		blk - block {
			# Block: BOT twitter (or tw) block <option> - to handle your block list
			switch -glob -- $l2 {
				+ - add {
					# Add someone to the block list
					set twhome [sbdget TWITTER:HOME]
					if [isempty twhome] {print $nick "You don't have a command channel set, you must set one to use this command."; return 0}
					if {[stl $chan] != [stl $twhome]} {print $nick "You cannot use this command in this channel, commands must be directed to ${twhome}"; return 0}

					set sid $3

					# Use twitter:senddata process ($handle $mode(opt.) $url $text(being sent) $query(if being used - the variable) $extra(optional variable))
					set www [twitter:senddata $handle block blocks/create/${sid}.json "" ""]

					# Process for 404 Page Not Found error
					set ncode [l0 $www]
					if [string eq 404 $ncode] {printh $nick "The page that is trying to be accessed cannot be found."; return 0}

					# Process 400 & Unknown Errors
					set code [l2 $www]
					set data [l1 $www]
					if [string eq -1 $ncode] { error "Unknown error: $data" }
					if [string eq 400 $ncode] {printh $nick "Couldn't retrieve the page you are requesting, please try again :: $code"; return 0}

					set nfo [list [json::json2dict $data]]
					foreach a $nfo {
						set id [dict get $a id]
						set sname [dict get $a screen_name]
					}

					print $nick "You are now blocking [stu $sname] ($id)"
					return 0
				}

				"-" - del* {
					# Remove someone from the block list
					set twhome [sbdget TWITTER:HOME]
					if [isempty twhome] {print $nick "You don't have a command channel set, you must set one to use this command."; return 0}
					if {[stl $chan] != [stl $twhome]} {print $nick "You cannot use this command in this channel, commands must be directed to ${twhome}"; return 0}

					set sid $3

					# Use twitter:senddata process ($handle $mode(opt.) $url $text(being sent) $query(if being used - the variable) $extra(optional variable))
					set www [twitter:senddata $handle block blocks/destroy/${sid}.json "" ""]

					# Process for 404 Page Not Found error
					set ncode [l0 $www]
					if [string eq 404 $ncode] {printh $nick "The page that is trying to be accessed cannot be found."; return 0}

					# Process 400 & Unknown Errors
					set code [l2 $www]
					set data [l1 $www]
					if [string eq -1 $ncode] { error "Unknown error: $data" }
					if [string eq 400 $ncode] {printh $nick "Couldn't retrieve the page you are requesting, please try again :: $code"; return 0}

					set nfo [list [json::json2dict $data]]
					foreach a $nfo {
						set id [dict get $a id]
						set sname [dict get $a screen_name]
					}

					print $nick "You are now unblocking [stu $sname] ($id)"
					return 0
				}

				chk - check {
					# Check to see if someone is on the block list
					set twhome [sbdget TWITTER:HOME]
					if [isempty twhome] {print $nick "You don't have a command channel set, you must set one to use this command."; return 0}
					if {[stl $chan] != [stl $twhome]} {print $nick "You cannot use this command in this channel, commands must be directed to ${twhome}"; return 0}

					set sid $3

					# Use twitter:senddata process ($handle $mode(opt.) $url $text(being sent) $query(if being used - the variable) $extra(optional variable))
					set www [twitter:senddata $handle "" blocks/exists/${sid}.json "" ""]

					# Process for 404 Page Not Found error
					set ncode [l0 $www]
					if [string eq 404 $ncode] {printh $nick "You are not blocking this user."; return 0}

					# Process 400 & Unknown Errors
					set code [l2 $www]
					set data [l1 $www]
					if [string eq -1 $ncode] { error "Unknown error: $data" }
					if [string eq 400 $ncode] {printh $nick "Couldn't retrieve the page you are requesting, please try again :: $code"; return 0}

					set nfo [list [json::json2dict $data]]
					foreach a $nfo {
						set id [dict get $a id]
						set sname [dict get $a screen_name]
					}

					print $nick "You are currently blocking [stu $sname] ($id)"
					return 0
				}

				lst - list {
					# List your blocked users
					set twhome [sbdget TWITTER:HOME]
					if [isempty twhome] {print $nick "You don't have a command channel set, you must set one to use this command."; return 0}
					if {[stl $chan] != [stl $twhome]} {print $nick "You cannot use this command in this channel, commands must be directed to ${twhome}"; return 0}

					# Use twitter:senddata process ($handle $mode(opt.) $url $text(being sent) $query(if being used - the variable) $extra(optional variable))
					set www [twitter:senddata $handle "" blocks/blocking.json "" ""]

					# Process for 404 Page Not Found error
					set ncode [l0 $www]
					if [string eq 404 $ncode] {printh $nick "You are not blocking this user."; return 0}

					# Process 400 & Unknown Errors
					set code [l2 $www]
					set data [l1 $www]
					if [string eq -1 $ncode] { error "Unknown error: $data" }
					if [string eq 400 $ncode] {printh $nick "Couldn't retrieve the page you are requesting, please try again :: $code"; return 0}

					set nfo [lreverse [json::json2dict $data]]
					set x 0
					foreach a $nfo {
						incr x
						set id [dict get $a id]
						set sname [dict get $a screen_name]
						set name [dict get $a name]

						print $nick "$x. $sname ($name) - ID: $id"
					}
					return 0
				}
			}
			return 0
		}

		fr - friend - friends {
			# Friends: BOT twitter (or tw) friends  - to retrieve a friend's timeline
			set twhome [sbdget TWITTER:HOME]
			if [isempty twhome] {print $nick "You don't have a command channel set, you must set one to use this command."; return 0}
			if {[stl $chan] != [stl $twhome]} {print $nick "You cannot use this command in this channel, commands must be directed to ${twhome}"; return 0}

			set twfreply [getdata $handle since_freplies_id]
			if [isempty twfreply] { set twfreply 1 }

			# Use twitter:senddata process ($handle $mode(opt.) $url $text(being sent) $query(if being used - the variable) $extra(optional variable))
			set www [twitter:senddata $handle friend statuses/home_timeline.json "" "" "since_id=$twfreply"]

			set data [l1 $www]
			set ncode [l0 $www]
			set code [l2 $www]

			set replies [lreverse [json::json2dict $data]]

			# Process 400 & Unknown Errors
			if [string eq -1 $ncode] { error "Unknown error: $data" }
			if [string eq 400 $ncode] {printh $nick "Couldn't retrieve your friend time line, will try again :: $code"; return 0}

			# Process for 404 Page Not Found error
			if [string eq 404 $ncode] {printh $nick "The page that is trying to be accessed cannot be found."; return 0}

			foreach reply $replies {
				set id [dict get $reply id]
				set user [dict get $reply user]
				set uname [dict get $user screen_name]
				set name [dict get $user name]

				set source [dict get $reply source]
				regexp -nocase -- {<a.+?>(.+?)</a>} $source all source

					set date [formattime [twitter:converttime [dict get $reply created_at]] $handle]

				set text [twitter:convert-unicode [SB:convert_html_codes [dict get $reply text]]]
				# Replace utf-8 entities that aren't covered by SB:convert_html_codes
				foreach {a b} [list \u2014 -- \u2019 ' \u2018 ' &#8212\\\; -- \u2013 -] {regsub -all $a $text $b text}

				if {[getdata $handle TWNAME] == $uname} {
					if {[sbdget TWITTER:DISP]} {
						print $nick "[color 13]$uname ($name): $text (Posted: $date) via $source[color] (MSG ID: $id)"
					} else {
						print $nick "[color 13]$uname: $text (Posted: $date) via $source[color] (MSG ID: $id)"
					}
				} else {
					if {[sbdget TWITTER:DISP]} {
						print $nick "$uname ($name): $text (Posted: $date) via $source (MSG ID: $id)"
					} else {
						print $nick "$uname: $text (Posted: $date) via $source (MSG ID: $id)"
					}
				}

				setdata $handle since_freplies_id $id
			}
			save
			return 0
		}

		rp - rpy - reply - men - mentions - replies { # Reply/Mentions code optimized for performance by Mai, thanks :)
			# Replies: BOT twitter (or tw) replies to retrieve your replies (@yourname) timeline
			set twhome [sbdget TWITTER:HOME]
			if [isempty twhome] {print $nick "You don't have a command channel set, you must set one to use this command."; return 0}
			if {[stl $chan] != [stl $twhome]} {print $nick "You cannot use this command in this channel, commands must be directed to ${twhome}"; return 0}

			set twreply [getdata $handle since_replies]
			if [isempty twreply] { set twreply 1 }

			# Use twitter:senddata process ($handle $mode(opt.) $url $text(being sent) $query(if being used - the variable) $extra(optional variable))
			set www [twitter:senddata $handle mentions statuses/mentions.json "" "" "since_id=$twreply"]

			set data [l1 $www]
			set ncode [l0 $www]
			set code [l2 $www]

			set replies [lreverse [json::json2dict $data]]

			# Process 400 & Unknown Errors
			if [string eq -1 $ncode] { error "Unknown error: $data" }
			if [string eq 400 $ncode] {printh $nick "Couldn't retrieve your mentions time line, will try again :: $code"; return 0}

			foreach reply $replies {
				set id [dict get $reply id]
				set user [dict get $reply user]
				set uname [dict get $user screen_name]
				set name [dict get $user name]

				set source [dict get $reply source]
				regexp -all -nocase -- {<a.+?>(.+?)</a>} $source all source

                    set date [formattime [twitter:converttime [dict get $reply created_at]] $handle]

				set text [twitter:convert-unicode [SB:convert_html_codes [dict get $reply text]]]
				# Replace utf-8 entities that aren't covered by SB:convert_html_codes
				foreach {a b} [list \u2014 -- \u2019 ' \u2018 ' &#8212\\\; -- \u2013 -] {regsub -all $a $text $b text}

				if {[sbdget TWITTER:DISP]} {
					print $nick "$uname ($name): $text (Posted: $date) via $source (MSG ID: $id)"
				} else {
					print $nick "$uname: $text (Posted: $date) via $source (MSG ID: $id)"
				}

				setdata $handle since_replies $id
			}
			save
			return 0
		}

		folow - follow {
			# Follow: BOT twitter (or tw) follow <name> to follow a user
			set twhome [sbdget TWITTER:HOME]
			if [isempty twhome] {print $nick "You don't have a command channel set, you must set one to use this command."; return 0}
			if {[stl $chan] != [stl $twhome]} { print $nick "You cannot use this command in this channel, commands must be directed to ${twhome}"; return 0}
			if [isempty l2] {print $nick "You must input a twitter account to follow."; return 0}

			# Use twitter:senddata process ($handle $mode(opt.) $url $text(being sent) $query(if being used - the variable) $extra(optional variable))
			set www [twitter:senddata $handle friend friendships/create/$jl2.json?follow=true "" $l2 screen_name]

			# Process for 403 Forbidden Response error
			set ncode [l0 $www]
			if [string eq 403 $ncode] {printh $nick "You are already following [stu $l2]"; return 0}

			# Process for 404 Page Not Found error
			if [string eq 404 $ncode] {printh $nick "The page that is trying to be accessed cannot be found."; return 0}

			print $nick "You are now following: [color 8][stu $l2][color]"
			return 0
		}

		uf - unfolow - unfollow {
			# Unfollow: BOT twitter (or tw) unfollow <name> to unfollow a user
			set twhome [sbdget TWITTER:HOME]
			if [isempty twhome] {print $nick "You don't have a command channel set, you must set one to use this command."; return 0}
			if {[stl $chan] != [stl $twhome]} { print $nick "You cannot use this command in this channel, commands must be directed to ${twhome}"; return 0}
			if [isempty l2] {print $nick "You must input a twitter account to unfollow."; return 0}

			# Use twitter:senddata process ($handle $mode(opt.) $url $text(being sent) $query(if being used - the variable) $extra(optional variable))
			set www [twitter:senddata $handle friend friendships/destroy/$jl2.json?follow=true "" $l2 screen_name]

			# Process for 403 Forbidden Response error
			set ncode [l0 $www]
			if [string eq 403 $ncode] {printh $nick "You are already unfollowing [stu $l2]"; return 0}

			# Process for 404 Page Not Found error
			if [string eq 404 $ncode] {printh $nick "The page that is trying to be accessed cannot be found."; return 0}

			print $nick "You are now unfollowing: [color 8][stu $l2][color]"
			return 0
		}

		trend - trending - trends {
			# Get the current top 10 trends
			# BOT twitter (or tw) trends
			set twhome [sbdget TWITTER:HOME]
			if [isempty twhome] {print $nick "You don't have a command channel set, you must set one to use this command."; return 0}
			if {[stl $chan] != [stl $twhome]} {print $nick "You cannot use this command in this channel, commands must be directed to ${twhome}"; return 0}

			# Use twitter:senddata process ($handle $mode(opt.) $url $text(being sent) $query(if being used - the variable) $extra(optional variable))
			set www [twitter:senddata $handle trends trends.json "" ""]
			set data [l1 $www]
			set ncode [l0 $www]

			# Process for 404 Page Not Found error
			if [string eq 404 $ncode] {printh $nick "The page that is trying to be accessed cannot be found."; return 0}

			set trending [list [json::json2dict $data]]

			foreach t $trending {
				set trends [dict get $t trends]

				# Format time Mon, 19 Oct 2009 07:50:48 +0000 into an integer 
				# converts it to Sat, May 26, 2007 @ 12:45 pm GMT
				# Taking in consideration for 8.4 backwards compatibility
				set asof [clock format [clock scan [lreplace [split [dict get $t as_of]] 5 5] -gmt true] -format "%a, %b %d, %Y @ %r %Z"]
				set x 0

				foreach a $trends {
					incr x
					set name [dict get $a name]
					set url [dict get $a url]

					print $nick "$x. $name - $url"
				}

				print $nick "Last update: $asof"
			}
			return 0
		}

		list - lists {
			# Manage your Twitter lists - Coming SOON
			switch -exact -- $l2 {
				create {
					# Create a list - accounts limited to 20 lists
					# http://api.twitter.com/1/user/lists.format
					return 0
				}

				update {
					# http://api.twitter.com/1/user/lists/id.format - id = name of list
					return 0
				}
			}
			return 0
		}

		su - search {
			# Search for users on Twitter
			# BOT twitter search <user>
			set twhome [sbdget TWITTER:HOME]
			if [isempty twhome] {print $nick "You don't have a command channel set, you must set one to use this command."; return 0}
			if {[stl $chan] != [stl $twhome]} {print $nick "You cannot use this command in this channel, commands must be directed to ${twhome}"; return 0}

			set user $2e
			regsub -all -nocase " " $user "%20" user

			# Use twitter:senddata process ($handle $mode(opt.) $url $text(being sent) $query(if being used - the variable) $extra(optional variable))
			set www [twitter:senddata $handle "" users/search.json "" "" "q=${user}"]

			set data [l1 $www]
			set lists [lreverse [json::json2dict $data]]
			set x 0

			foreach u $lists {
				incr x
				set name [dict get $u name]
				set screen_name [dict get $u screen_name]
				set location [dict get $u location]
				set verified [dict get $u verified]
				set desc [dict get $u description]
				set follow [dict get $u following]
				set created [clock format [clock scan [lreplace [split [dict get $u created_at]] 4 4] -gmt true] -format "%a, %b %d, %Y @ %r %Z"]

				print $nick "$x. \002$name ($screen_name)\002"
				print $nick "Description: $desc"
				print $nick "Location: $location"
				print $nick "Verified: $verified"
				print $nick "Following: $follow"
				print $nick "Created: $created"
			}
			print $nick ">End Search"
			return 0
		}

		fav - favorite - favorites {
			# View your favoirted tweets
			# BOT twitter (or tw) favorites
			set twhome [sbdget TWITTER:HOME]
			if [isempty twhome] {print $nick "You don't have a command channel set, you must set one to use this command."; return 0}
			if {[stl $chan] != [stl $twhome]} {print $nick "You cannot use this command in this channel, commands must be directed to ${twhome}"; return 0}

			# Use twitter:senddata process ($handle $mode(opt.) $url $text(being sent) $query(if being used - the variable) $extra(optional variable))
			set www [twitter:senddata $handle "" favorites.json "" ""]
			set data [l1 $www]
			set ncode [l0 $www]

			set fav [lreverse [json::json2dict $data]]
			set x 0

			# Process 400 & Unknown Errors
			if [string eq -1 $ncode] { error "Unknown error: $data" }
			if [string eq 400 $ncode] {printh $nick "Couldn't retrieve your friend time line, will try again :: $code"; return 0}

			# Process for 404 Page Not Found error
			if [string eq 404 $ncode] {printh $nick "The page that is trying to be accessed cannot be found."; return 0}

			foreach f $fav {
				incr x
				set user [dict get $f user]
				set uname [dict get $user screen_name]
				set name [dict get $user name]

				set source [dict get $f source]
				regexp -nocase -- {<a.+?>(.+?)</a>} $source all source

				set date [formattime [twitter:converttime [dict get $f created_at]] $handle]

				set text [twitter:convert-unicode [SB:convert_html_codes [dict get $f text]]]
				# Replace utf-8 entities that aren't covered by SB:convert_html_codes
				foreach {a b} [list \u2014 -- \u2019 ' \u2018 ' &#8212\\\; -- \u2013 -] {regsub -all $a $text $b text}

				if {[getdata $handle TWNAME] == $uname} {
					if {[sbdget TWITTER:DISP]} {
						print $nick "$x. [color 13]$uname ($name): $text (Posted: $date) via $source[color]"
					} else {
						print $nick "$x. [color 13]$uname: $text (Posted: $date) via $source[color]"
					}
				} else {
					if {[sbdget TWITTER:DISP]} {
						print $nick "$x. $uname ($name): $text (Posted: $date) via $source"
					} else {
						print $nick "$x. $uname: $text (Posted: $date) via $source"
					}
				}
			}
			print $nick ">End Favorites"
			return 0
		}

		"-" - del* {
			# Delete a tweet you've sent
			# BOT twitter delete <msg id>
			set twhome [sbdget TWITTER:HOME]
			if [isempty twhome] {print $nick "You don't have a command channel set, you must set one to use this command."; return 0}
			if {[stl $chan] != [stl $twhome]} {print $nick "You cannot use this command in this channel, commands must be directed to ${twhome}"; return 0}

			set id $2

			# Use twitter:senddata process ($handle $mode(opt.) $url $text(being sent) $query(if being used - the variable) $extra(optional variable))
			set www [twitter:senddata $handle deltweet statuses/destroy.json "" $id id]

			# Process for 404 Page Not Found error
			set ncode [l0 $www]
			if [string eq 404 $ncode] {printh $nick "The page that is trying to be accessed cannot be found."; return 0}

			# Process 400 & Unknown Errors
			set code [l2 $www]
			set data [l1 $www]
			if [string eq -1 $ncode] { error "Unknown error: $data" }
			if [string eq 400 $ncode] {printh $nick "Couldn't retrieve your tweets, please try again :: $code"; return 0}

			# Retrieve tweet for deletion
			set tweet [list [json::json2dict $data]]
			foreach a $tweet {
				set text [dict get $a text]
				set id [dict get $a id]
				print $nick "Deleted tweet: \"$text\" (MSG ID: $id)"
			}
			return 0
		}

		default {
			# Default command option: to send a message
			# BOT twitter (or tw) <msg>
			set twhome [sbdget TWITTER:HOME]
			if [isempty twhome] {print $nick "You don't have a command channel set, you must set one to use this command."; return 0}
			if {[stl $chan] != [stl $twhome]} {print $nick "You cannot use this command in this channel, commands must be directed to ${twhome}"; return 0}

			set text $j1e

			# Use twitter:senddata process ($handle $mode(opt.) $url $text(being sent) $query(if being used - the variable) $extra(optional variable))
			set www [twitter:senddata $handle tweet statuses/update.json $text "" status]

			# Process for 403 Forbidden Response error
			set ncode [l0 $www]
			if [string eq 403 $ncode] {printh $nick "You have reached your API limit. Cannot send tweet."; return 0}

			# Process for 404 Page Not Found error
			if [string eq 404 $ncode] {printh $nick "The page that is trying to be accessed cannot be found."; return 0}

			# Process 400 & Unknown Errors
			set code [l2 $www]
			set data [l1 $www]
			if [string eq -1 $ncode] {error "Unknown error: $data"}
			if [string eq 400 $ncode] {printh $nick "Couldn't send your tweet, please try again :: $code"; return 0}

			return 0
		}
	}
}

# Generates the HTTP authentication header that we'll need to use
# Code courtesy of http://www.robsayers.com/programming/Twittertcl.html
proc authheader {username passwd} { list Authorization [concat Basic [base64::encode [join $username]:[join $passwd]]] }

# Process to send data to Twitter - Thank you Mai for writing this, wouldn't have thought to do it this way
# Enter with:
#     $HANDLE (handle of person sending data)
#     $MODE (retweet, or whatever we're doing: this is optional)
#     $URL (status/update.json)
#     $TEXT (whatever text you're sending)
#     $QUERY (HTTP query variable to use)
#     $EXTRA (optional variable, needed for (re)tweet, (un)follow, direct message)
#     $DMTO (for direct message, variable holding person you are sending to)

proc twitter:senddata { handle mode url text query { extra "" } { dmto "" } } {
	upvar 1 nick nick
	upvar 1 query q

	# Hard variables
	set truncate 140
	set complain 0; # Set to 1 to throw a bead error for when messages are > 140 characters

	set headers [authheader [getdata $handle TWNAME] [getdata $handle TWPSWD]]

	if [string eq "trends" $mode] {
		set url "http://search.twitter.com/${url}"
	} elseif [string eq "list" $mode] {
		set url "http://api.twitter.com/1/[getdata $handle TWNAME]/${url}"
	} elseif [isempty extra] {
		set url "http://twitter.com/${url}"
	} elseif {([isempty query] && ([string eq "tweet" $mode] || [string eq "retweet" $mode] || [string eq "direct" $mode]))} {
		set url "http://twitter.com/${url}"
	} elseif {([notempty extra] && [isempty query])} {
		set url "http://twitter.com/${url}?${extra}"
	} else {
		set url "http://twitter.com/${url}"
	}

	# Work with URL shorteners
	set newtext ""
	foreach word [split $text] {
		if {[regexp {^www\.} $word] && ([string length $word] > [expr {[getdata $handle TWSHORTEN] + 6}])} {
			append newtext "[twitter:shorten $handle  "http://$word" [getdata $handle TWSHORTENER]] "
		} elseif {[regexp {^http\:} $word] && [string length $word] > [getdata $handle TWSHORTEN]} {
			append newtext "[twitter:shorten $handle $word [getdata $handle TWSHORTENER]] "
		} else {
			append newtext "$word "
		}
	}

	set text [string trim $newtext]

	# Twitter has a 140 character limit
	# [ 02:46:33 pm | 240910.24 ]   [ Demon|Away ] trying to post something to my account through the api that just happens to be > 140 characters and it's not hitting my account
	# [ 02:47:42 pm | 240910.24 ]   [ noradio ] yeah you can no longer post tweets longer than 140 characters
	if {([len $text] > $truncate) && $complain} { return [list -1 "Tweets are limited to a total of $truncate characters. I couldn't submit your tweet. Your text would clip here: \"[mid $text [expr $truncate + 1] 40]\" <SNIP>"] }
	if {[len $text] <= $truncate} {
		if {([notempty query] && [isempty text])} { 
			set q [http::formatQuery $extra $query]
		} elseif {([isempty query] && [notempty text] && ![string eq "direct" $mode])} {
			set q [http::formatQuery $extra $text]
		} elseif {([string eq "direct" $mode] && [notempty text] && [notempty extra] && [notempty dmto])} {
			set q [http::formatQuery [l0 $extra] $text [l1 $extra] $dmto]
		} elseif {([string eq "block" $mode] && [isempty query] && [isempty text])} {
			set q [http::formatQuery $text $query]
		}
		# Let's separate this, since there's an opportunity to send via a different URL tweets > 140 chars

		set ::http::defaultCharset "utf-8"

		if [isempty q] {
			set error [catch { set token [::http::geturl $url -headers $headers] } shit]
		} else {
			set error [catch { set token [::http::geturl $url -headers $headers -query $q] } shit]
		}

		if [string eq "trends" $mode] {
			set error [catch { set token [::http::geturl $url] } shit]
		}

		if $error {return [list -1 $shit]}; # Error code for failed send
		set ncode [http::ncode $token]
		set data [http::data $token]
		set code [http::code $token]
		::http::cleanup $token

		if ![string eq 400 $ncode] {
			if [string eq "tweet" $mode] {
				set tweets [list [json::json2dict $data]]
				foreach tw $tweets {
					set id [dict get $tw id]
					set text [dict get $tw text]
				}
				print $nick "Your tweet has been submitted: $text (MSG ID: $id)"
			}
			if [string eq "retweet" $mode] {
				set retweets [list [json::json2dict $data]]
				foreach rtw $retweets {
					set id [dict get $rtw id]
					set text [dict get $rtw text]
				}
				print $nick "Your retweet has been submitted: $text (MSG ID: $id)"
			}
			if [string eq "direct" $mode] {print $nick "Your direct message has been sent to: $dmto"}
		}

		# Process 502 Twitter Over Capacity
		if [string eq 502 $ncode] {printh $nick "Twitter / Over capacity :: $code"; return 0}

		# Process 503 Server Unavailable Errors
		if [string eq 503 $ncode] {printh $nick "No available server to handle this request :: $code"; return 0}

		return [list $ncode $data $code]
	} else {
		if {([notempty query] && [isempty text])} { 
			set q [http::formatQuery $extra $query] 
		} elseif {([isempty query] && [notempty text] && ![string eq "direct" $mode])} {
			set old_text $text
			set text [twitter:replacetext $text]

			if {[len $text] > $truncate} {
				printh $nick "I've shortened this to a total of [len $text] characters, yet it's still too long. Use a service like http://www.twitlonger.com to submit this tweet, or send in multiple parts."
				printh $nick "Submitted text: $old_text"
				printh $nick "Shortened text: $text"
				printh $nick "Snipped at: [mid $text [expr $truncate + 1] 40]"

				if [string eq "tweet" $mode] {print $nick "Your tweet could not be submitted."; return 0}
				if [string eq "retweet" $mode] {print $nick "Your retweet could not be submitted."; return 0}
			}

			set q [http::formatQuery $extra $text]
		} elseif {([string eq "direct" $mode] && [notempty text] && [notempty extra] && [notempty dmto])} {
			set old_text $text
			set text [twitter:replacetext $text]

			if {[len $text] > $truncate} {
				printh $nick "I've shortened this to a total of [len $text] characters, yet it's still too long. Use a service like http://www.twitlonger.com to submit this tweet, or send in multiple parts."
				printh $nick "Submitted text: $old_text"
				printh $nick "Shortened text: $text"
				printh $nick "Snipped at: [mid $text [expr $truncate + 1] 40]"

				if [string eq "direct" $mode] {print $nick "Your direct message could not be sent to: $dmto."; return 0}
			}

			set q [http::formatQuery [l0 $extra] $text [l1 $extra] $dmto]
		}

		set ::http::defaultCharset "utf-8"

		if [isempty q] {
			set error [catch { set token [::http::geturl $url -headers $headers] } shit]
		} else {
			set error [catch { set token [::http::geturl $url -headers $headers -query $q] } shit]
		}

		if $error {return [list -1 $shit]}; #Error code for failed send
		set ncode [http::ncode $token]
		set data [http::data $token]
		set code [http::code $token]

		if ![string eq 400 $ncode] {
			if [string eq "tweet" $mode] {
				set tweets [list [json::json2dict $data]]
				foreach tw $tweets {
					set id [dict get $tw id]
					set text [dict get $tw text]
				}
				print $nick "Your tweet has been submitted: $text (MSG ID: $id)"
			}
			if [string eq "retweet" $mode] {
				set retweets [list [json::json2dict $data]]
				foreach rtw $retweets {
					set id [dict get $rtw id]
					set text [dict get $rtw text]
				}
				print $nick "Your retweet has been submitted: $text (MSG ID: $id)"
			}
			if [string eq "direct" $mode] {print $nick "Your direct message has been sent to: $dmto"}
		}

		# Process 502 Twitter Over Capacity
		if [string eq 502 $ncode] {printh $nick "Twitter / Over capacity :: $code"; return 0}

		# Process 503 Server Unavailable Errors
		if [string eq 503 $ncode] {printh $nick "No available server to handle this request :: $code"; return 0}

		::http::cleanup $token
		return [list $ncode $data $code]
	}
	return 0; # Error code for OK.
}

proc twitter:replacetext text {
	# Start a list of words to be shortened
	array set list ""
	set list(1) [list you U you're yr four 4 tomorrow 2morrow about abt to 2 two 2 because b/c with w/]
	set list(2) [list without w/out for 4 and \046 be B sorry sry this ths toady 2day why y text txt]
	set list(3) [list our R are R next nxt would wld like lk want wnt one 1 see C really rlly these ths]
	set list(4) [list won't wnt i've ive "bye for now" BFN background BG "best regards" BR "by the way" BTW]
	set list(5) [list "direct message" DM email EM facebook FB "face to face" FTF "for what it's worth" FWIW]
	set list(6) [list great Gr8 "in my opinion" IMO "in my honest opinion" IMHO "in my humble opinion" IMHO]
	set list(7) [list "in real life" IRL "just kidding" J/K LinkedIn LI "let me know" LMK "laughing my butt off" LMBO]
	set list(8) [list "laughin my ass off" LMAO "laughin out loud" LOL "no problem" NP "oh my god" OMG]
	set list(9) [list "oh my fucking god" OMFG please plz "rolling on the floor laughing" ROFL retweet RT]
	set list(10) [list "thanks for the retweet" RTHX "tweet me back" TMB "too much information" TMI]
	set list(11) [list "talk to you soon" TTYS "talk to you later" TTYL "thank you" TY "what the heck" WTH]
	set list(12) [list "what the hell" WTH "what the fuck" WTF "you're welcome" YW "you are welcome" YW]

	foreach x [lsort -int -inc [array names list]] {
		set item $list($x)
		foreach {find replace} $item {
			set text [ldestroy -all -nonulls -replace $text $find $replace]
		}
	}

	return $text
}

# Thanks again to Mai for writing this process. I would have had no idea on how to handle the unicode conversion.
proc twitter:convert-unicode { text { convert_to "utf-8"} } {
	set regexp [regexp -inline -all -- {\\u....} $text]
	# Tighter restraint?
	# set regexp [regexp -inline -all -nocase -- {\\u[0-9a-f]{4}} $text]
	foreach item $regexp {
		set item_split [split $item]
		set mid [mid $item 3];
		set dec [dec \$$mid];
		eval set char $item;
		regsub -all -- $item_split $text $char text
	}

	return [encoding convertto $convert_to $text]
}

# Another one by Mai ....
proc twitter:converttime date {
	if ![regexp -nocase -- {^[A-Z]{3} [A-Z]{3} \d\d \d\d:\d\d:\d\d [\+\-]\d{4} \d{4}$} $date] {return $date}
	lassign $date day month date time zone year
	#lassign [split $time :] hour monute second
	set timestamp [clock scan "$date $month $year $time"]
	set yourzone [nozero [left $zone 3][mantissa [ fixmath [ right $zone 2 ] / 60 ]]]
	set my [clock format [now] -format %z]
	set myzone [nozero [left $my 3][mantissa [ fixmath [ right $my 2 ] / 60 ]]]
	if [string compare $myzone $yourzone] {
		add timestamp [ fixmath ( $myzone - $yourzone ) * 3600 ]
		int timestamp
	}

	return $timestamp; # Adjusted so it'll print the time relative to YOUR timezone
}

proc twitter:shorten {handle url type} {
	# 0=is.gd, 1=moourl.com, 2=bit.ly, 3=cli.gs
	# moourl.com is unavalable until they release an api
	set agent "User Agent: Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US; rv:1.9.2.3) Gecko/20100401 Firefox/3.6.3 GTB7.0 ( .NET CLR 3.5.30729)"
	set www [::http::config -useragent $agent -urlencoding "utf-8"]

	switch -- $type {
		0 {set query "http://is.gd/api.php?[http::formatQuery longurl $url]"}
#		1 {set query "http://moourl.com/create/?[http::formatQuery source $url]"}
		2 {set query "http://api.bit.ly/v3/shorten?[http::formatQuery login [getdata $handle BITLY-USERNAME] apiKey [getdata $handle BITLY-APIKEY] longUrl $url format txt]"}
		3 {set query "http://cli.gs/api/v1/cligs/create?[http::formatQuery url $url]&title=&key=&appid=StormbotTCL"}
	}

	set token [http::geturl $query -timeout 10000]
	upvar #0 $token state
	if {![string match "* *" $state(body)]} { return [string map {"\n" ""} $state(body)] }
	return $url
}
