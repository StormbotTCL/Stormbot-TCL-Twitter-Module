# Twitter Client through SB6
#
# Using BOT twitter (or tw) <msg> to send a tweet
# Retweet: BOT twitter (or tw) retweet (or rt) <name> <msg> to retweet a message
# Direct Message: BOT twitter (or tw) dm <name> <msg> to direct message one of your followers
# Friends: BOT twitter (or tw) friends to retrieve a friend's timeline
# Replies: BOT twitter (or tw) replies to retrieve your replies (@yourname) timeline
# Follow: BOT twitter (or tw) follow <name> to follow a user
# Unfollow: BOT twitter (or tw) unfollow <name> to unfollow a user
#
# It is required to place your bot in a channel dedicated to twitter as to not disrupt another channel's chatter
#
# TODO:
#   * Store twitter username and password to bot user data file via /msg bot ONLY (security reasons) (DONE - Thanks Mai!)
#   * Work on handling the different retrieval methods (DONE)
#   * Write the help on the commands (DONE)
#   * Better handle (re)tweets and direct messages greater than 140 characters (DONE)
#   * Implement oAuth.
#   * Implement URL shorteners of is.gd, moourl.com, bit.ly, or cli.gs
#
# Change Log:
# Please refer to http://github.com/demonicpagan/Stormbot-TCL-Twitter-Module for changes made

SB:command add TWITTER 1 -none TW
SB:register variable global TWITTER:*
sbdset SB:author "Dustin Shea (demonicpagan@gmail.com)"

# Make sure the require packages are installed
empty package_failed
foreach package [list base64 json http sha1] {
	set error [catch {package require $package} shit]
	if $error {lappend package_failed $package}
}
sbdset TWITTER:PACKAGE_FAIL $package_failed
unset package_failed

# oAuth TCL library by horgh (www.summercat.com) for Twitter
namespace eval oauth {
	variable consumer_key [sbdget TWITTER:CONSUMER_KEY]
	variable consumer_secret [sbdget TWITTER:CONSUMER_SECRET]

	variable request_token_url http://api.twitter.com/oauth/request_token
	variable authorize_url https://api.twitter.com/oauth/authorize
	variable access_token_url http://api.twitter.com/oauth/access_token

	variable timeout 60000
}

# first step
proc oauth:get_request_token {} {
	set params [list [list oauth_callback oob]]
	set data [oauth:query_call $oauth::request_token_url GET $params]

	# dict has oauth_token, oauth_token_secret, ...
	set result [oauth:params_to_dict $data]
	dict append result auth_url ${oauth::authorize_url}?[http::formatQuery oauth_token [dict get $result oauth_token]]

	return $result
}

# second step
# for twitter, oauth_verifier is pin
# oauth_token & oauth_token_secret from get_request_token
proc oauth::get_access_token {oauth_token oauth_token_secret oauth_verifier} {
	set params [list [list oauth_token $oauth_token] [list oauth_verifier $oauth_verifier]]
	set result [oauth:query_call $oauth::access_token_url POST $params]

	# dict has oauth_token, oauth_token_secret (different than before), ...
	return [oauth:params_to_dict $result]
}

# after first two steps succeed, we now can make api requests to twitter
# query_dict is POST request to twitter as before, key:value pairing (dict)
# oauth_token, oauth_token_secret from get_access_token
proc oauth:query_api {url method oauth_token oauth_token_secret query_dict} {
	set params [list [list oauth_token $oauth_token]]
	set result [oauth:query_call $url $method $params $query_dict $oauth_token_secret]
	return $result
}

# build header & query, call http request and return result
# params stay in oauth header
# sign_params are only used in base string for signing (optional) - dict
proc oauth:query_call {url method params {sign_params {}} {token_secret {}}} {
	set oauth_raw [dict create oauth_nonce [oauth:nonce]]
	dict append oauth_raw oauth_signature_method HMAC-SHA1
	dict append oauth_raw oauth_timestamp [clock seconds]
	dict append oauth_raw oauth_consumer_key $oauth::consumer_key
	dict append oauth_raw oauth_version 1.0

	# variable number of params
	foreach param $params {
		dict append oauth_raw {*}$param
	}
	# second oauth_raw holds data to be signed but not placed in header
	set oauth_raw_sign $oauth_raw
	foreach key [dict keys $sign_params] {
		dict append oauth_raw_sign $key [dict get $sign_params $key]
	}

	set signature [oauth:signature $url $method $oauth_raw_sign $token_secret]
	dict append oauth_raw oauth_signature $signature

	set oauth_header [oauth:oauth_header $oauth_raw]
	set oauth_query [oauth:uri_escape $sign_params]

	return [oauth:query $url $method $oauth_header $oauth_query]
}

# do http request with oauth header
proc oauth:query {url method oauth_header {query {}}} {
	set header [list Authorization [concat "OAuth" $oauth_header]]
msghome OAUTH:HEADER($header)
msghome OAUTH:QUERY($query)
msghome OAUTH:METHOD($method)
msghome OAUTH:URL($url)
	set token [http::geturl $url -headers $header -query $query -method $method -timeout $oauth::timeout]
	set data [http::data $token]
	set ncode [http::ncode $token]
	http::cleanup $token
	# if {$ncode != 200} {
		# error "OAuth failure: (code: $ncode) $data"
		# return 0
	# }
	set result [json::json2dict $data]
	if [string eq 401 $ncode] {error "[dict get $result error]. (code: $ncode)"; return 0}
	if [string eq 403 $ncode] {error "You have reached your API limit, or you may already be (un)following this person. (code: $ncode)"; return 0}
	if [string eq 404 $ncode] {error "The page that is trying to be accessed cannot be found. (code: $ncode)"; return 0}
	if [string eq -1 $ncode] {error "Unknown error: $data"; return 0}
	if [string eq 400 $ncode] {error "Couldn't send/retrieve your tweet(s)/mentions/timeline/direct message/block list, please try again. (code: $ncode)"; return 0}
	if [string eq 502 $ncode] {error "Twitter / Over capacity. (code: $ncode)"; return 0}
	if [string eq 503 $ncode] {error "No available server to handle this request. (code: $ncode)"; return 0}

	return $data
}

# take a dict of params and create as follows:
# create string as: key="value",...,key2="value2"
proc oauth:oauth_header {params} {
	set header []
	foreach key [dict keys $params] {
		set header "${header}[oauth:uri_escape $key]=\"[oauth:uri_escape [dict get $params $key]]\","
	}
	return [string trimright $header ","]
}

# take dict of params and create as follows
# sort params by key
# create string as key=value&key2=value2...
# TODO: if key matches, sort by value
proc oauth:params_signature {params} {
	set str []
	foreach key [lsort [dict keys $params]] {
		set str ${str}[oauth:uri_escape [list $key [dict get $params $key]]]&
	}
	return [string trimright $str &]
}

# build signature as in section 9 of oauth spec
# token_secret may be empty
proc oauth:signature {url method params {token_secret {}}} {
	# We want base URL for signing (remove ?params=...)
	set url [l0 [split $url "?"]]
	set base_string [oauth:uri_escape ${method}]&[oauth:uri_escape ${url}]&[oauth:uri_escape [oauth:params_signature $params]]
	set key [oauth:uri_escape $oauth::consumer_secret]&[oauth:uri_escape $token_secret]
	set signature [sha1::hmac -bin -key $key $base_string]
	return [base64::encode $signature]
}

proc oauth:nonce {} {
	set nonce [clock milliseconds][expr [tcl::mathfunc::rand] * 10000]
	return [sha1::sha1 $nonce]
}

# wrapper around http::formatQuery which uppercases octet characters
proc oauth:uri_escape {str} {
	set str [http::formatQuery {*}$str]
	# uppercase all %hex where hex=2 octets
	set str [regsub -all -- {%(\w{2})} $str {%[string toupper \1]}]
	return [subst $str]
}

# convert replies from http query into dict
# params of form key=value&key2=value2
proc oauth:params_to_dict {params} {
	set answer []
	foreach pair [split $params &] {
		dict set answer {*}[split $pair =]
	}
	return $answer
}

namespace eval twitter {
	variable oauth_token
	variable oauth_token_secret

	# Twitter API URLs
	variable status_url "http://api.twitter.com/1/statuses/update.json" ; # POST
	variable status_del_url "http://api.twitter.com/1/statuses/destroy.json" ; # POST destroy.json?id=123
	variable home_url "http://api.twitter.com/1/statuses/home_timeline.json" ; # GET home_timeline.json?since_id=12345
	variable ment_url "http://api.twitter.com/1/statuses/mentions.json" ; # GET mentions.json?since_id=12345
	variable dmsg_send_url "http://api.twitter.com/1/direct_messages/new.json" ; # POST new.json?user=noradio&text=test text
	variable dmsg_list_url "http://api.twitter.com/1/direct_messages.json" ; # GET
	variable dmsg_del_url "http://api.twitter.com/1/direct_messages/destroy.json" ; # POST destroy.json?id=12345
	variable trends_url "http://api.twitter.com/1/trends.json" ; # GET
	variable follow_url "http://api.twitter.com/1/friendships/create/twitterapi.json" ; # POST twitterapi.json?screen_name=noradio
	variable unfollow_url "http://api.twitter.com/1/friendships/destroy.json" ; # POST destroy.json?screen_name=noradio
	variable search_usr_url "http://api.twitter.com/1/users/search.json" ; # GET search.json?q=noradio
	variable rate_limit_url "http://api.twitter.com/1/account/rate_limit_status.json" ; # GET
	variable update_pro_url "http://api.twitter.com/1/account/update_profile.json" ; # POST
	variable show_pro_url "http://api.twitter.com/1/users/show.json" ; # GET show.json?screen_name=noradio
	variable block_add_url "http://api.twitter.com/1/blocks/create.json" ; # POST create.json?screen_name=noradio
	variable block_del_url "http://api.twitter.com/1/blocks/destroy.json" ; # POST destroy.json?screen_name=noradio
	variable block_chk_url "http://api.twitter.com/1/blocks/exists.json" ; # GET exists.json?screen_name=noradio
	variable block_list_url "http://api.twitter.com/1/blocks/blocking.json" ; # GET
	variable fav_list_url "http://api.twitter.com/1/favorites.json" ; # GET
	variable retweet_url "http://api.twitter.com/1/statuses/retweet/" ; # POST id.json where id is the message id
}

proc SB:proc_twitter {nick host handle chan arg} {
	set package_failed [sbdget TWITTER:PACKAGE_FAIL]
	SB:setvariables

	set disp [sbdget TWITTER:DISP]
	if {$disp == ""} { set disp 0 }

	# Set $DCCOKAY to 0 (only allow /MSG commands), or 1 (/MSG & .DCC are okay).
	set dccokay 0

	# Help information
	if [string eq -nocase HELP $1] {
		printh $nick "\[TWITTER\]:"
		printh $nick "This command will essentially turn your Stormbot eggdrop bot into a twitter client."
		printh $nick "It is best to when using this command, place your bot in its own channel."
		printh $nick ""
		if [string eq ALL $u2] {
			if [SB:checklevel [sbd:get USERLEVEL:BOTOWNER] $handle] {
				printh $nick "\002 Storing your Twitter credentials/Locking Channel\002"
				printh $nick "/msg $::botnick TWITTER SETKEY <consumer key>"
				printh $nick "/msg $::botnick TWITTER SETSECRET <consumer secret>"
				printh $nick "These are obtained by registering the bot as an app at: https://twitter.com/apps"
				printh $nick ""
				printh $nick "Syntax: $::botnick TWITTER RESTRICT <channel> (Only use twitter in this channel, must have 1000 access on the bot to set) - MUST BE SET!."
			} else {
				printh $nick "\002Client Option\002"
					printh $nick "Syntax: $::botnick TWITTER DISPLAY <off/on> (Display the readable name of twitter user)"
					printh $nick "Syntax: $::botnick TWITTER STATUS (Display the rate limit status of your account)"
					printh $nick "Syntax: $::botnick TWITTER PROFILE SET (-name|-url|-location|-description) (Sets your profile information)"
					printh $nick "Syntax: $::botnick TWITTER SHORTEN <number> (Set the length of url's that will be shortened. 12-20 recommended)"
					printh $nick "Syntax: $::botnick TWITTER SHORTENER <option> (0=is.gd, 1=moourl.com, 2=bit.ly, 3=cli.gs)"
					printh $nick "Syntax: $::botnick TWITTER BITLYUN (Your bit.ly account username)"
					printh $nick "Syntax: $::botnick TWITTER BITLYAPI (Your bit.ly account API key)"
				printh $nick ""
				printh $nick "\002Client commands\002"
					printh $nick "Syntax: $::botnick TWITTER REQTOKEN (Request your oAuth token)"
					printh $nick "Syntax: $::botnick TWITTER ACCTOKEN <oauth token> <oauth token secret> <PIN from authentication url of $::botnick TWITTER REQTOKEN> (Use your token)"
					printh $nick "Syntax: $::botnick TWITTER <message text> (Send a status update to twitter - 140 Char limit)"
					printh $nick "Syntax: $::botnick TWITTER DELETE <msg id #> (Delete a tweet YOU sent)"
					printh $nick "Syntax: $::botnick TWITTER FOLLOW <screen name> (Follow a twitter user - Can only be used in Twitter channel)"
					printh $nick "Syntax: $::botnick TWITTER UNFOLLOW <screen name> (Unfollow a twitter user)"
					printh $nick "Syntax: $::botnick TWITTER FRIENDS (Displays your public timeline that includes your friends' tweets)"
					printh $nick "Syntax: $::botnick TWITTER MENTIONS (Displays messages directed at you.)"
					printh $nick "Syntax: $::botnick TWITTER RETWEET <id> (Retweet a message that you found interesting)"
					printh $nick "Syntax: $::botnick TWITTER DIRECT SEND <name> <msg> (Send a direct message to a user - 140 Char limit)"
					printh $nick "Syntax: $::botnick TWITTER DIRECT LIST (lists your direct messages and their id number)"
					printh $nick "Syntax: $::botnick TWITTER DIRECT DEL <msg id #> (deletes a direct message)"
					printh $nick "Syntax: $::botnick TWITTER BLOCK ADD <screen name> (Add someone to the block list)"
					printh $nick "Syntax: $::botnick TWITTER BLOCK DEL <screen name> (Remove someone from the block list)"
					printh $nick "Syntax: $::botnick TWITTER BLOCK CHECK <screen name> (Check to see if someone is on your block list)"
					printh $nick "Syntax: $::botnick TWITTER BLOCK LIST (List your blocked people)"
					printh $nick "Syntax: $::botnick TWITTER TRENDS (Displays the current top 10 trending topics with the search URL)"
					printh $nick "Syntax: $::botnick TWITTER FAVORITES (Displays your favorited tweets)"
					printh $nick "Syntax: $::botnick TWITTER PROFILE VIEW <screen name> (View a users profile)"
					printh $nick "Syntax: $::botnick TWITTER SEARCH <screen name> (Search for a profile - returns the first 5 results)"
			}
		} else {
			printh $nick "To see all available options, use: $::botnick TWITTER HELP ALL"
		}

		printh $nick ""
		printh $nick "NOTICE: If your tweet, direct message, retweet contains a URL and you go over the 140 character limit, use a url shortener"
		printh $nick "like tinyurl.com, bit.ly, moourl.com, is.gd, or any other url shortener that you know of and resubmit your tweet."

		if [notempty package_failed] {
			printh $nick ""
			printh $nick "I'm sorry, but I can't execute the TWITTER command: I'm missing some code packages ([ajl $package_failed]). Please have my owner install these packages so I can run this command."
		}
		return 0
	}


	if [notempty package_failed] {print $nick "I'm sorry, but I can't execute the TWITTER command: I'm missing some code packages ([ajl $package_failed]). Please have my owner install these packages so I can run this command."; return 0}
	switch -glob -- $l1 {

		ky - key - consumerkey - setky - setkey - setconsumerkey {
			if $dccokay {
				if [sbd:equal -nocase @LAST_TRIGGER PUB] {printh $nick "You may not use this command in channel, for security purposes. Use either /MSG or .DCC to use this command."; return 0}
			} else {
				if ![sbd:equal -nocase @LAST_TRIGGER MSG] {printh $nick "You may only use this command in /MSG format for security purposes."; return 0}
			}

			sbdset TWITTER:CONSUMER_KEY $2
			SB:botdatafile write
			print $nick "Your TWITTER API Consumer Key has been saved."
			return 0
		}

		secret - consumersecret - setsecret - setconsumersecret {
			if $dccokay {
				if [sbd:equal -nocase @LAST_TRIGGER PUB] {printh $nick "You may not use this command in channel, for security purposes. Use either /MSG or .DCC to use this command."; return 0}
			} else {
				if ![sbd:equal -nocase @LAST_TRIGGER MSG] {printh $nick "You may only use this command in /MSG format for security purposes."; return 0}
			}

			sbdset TWITTER:CONSUMER_SECRET $2
			SB:botdatafile write
			print $nick "Your TWITTER API Consumer Secret has been saved."
			return 0
		}

		lc - lock* - chan - rest* {
			set editaccess 1000
			if ![SB:checkaccess $editaccess $handle $chan] {printh $nick "You are not permitted to edit this setting."; return 0}
			set twhome [sbdget TWITTER:HOME]
			set thome $j2

			if [string eq "" $2] {
				if [isempty twhome] {
					print $nick "TWITTER command channel has not been set, please set one."; return 0
				} else {
					print $nick "Current TWITTER command channel: ${twhome}"; return 0
				}
			}

			if {[lsearch -exact [list OFF NONE CLEAR] $ju2] > -1} {
				sbdset TWITTER:HOME
				SB:botdatafile write
				print $nick "TWITTER command channel setting has been cleared."
				return 0
			}

			if {![validchan $thome] && ![isempty twhome]} {print $nick "${thome} is not currently a channel I reside on."; return 0}
			if {[stl $thome] == [stl $twhome]} {printh $nick "The TWITTER command channel is already set to: ${twhome}"; return 0}

			sbdset TWITTER:HOME $thome
			SB:botdatafile write
			printh $nick "Setting the TWITTER command channel to ${thome}"
			return 0
		}

		dis - disp - display {
			# Display the readable format of a twitter user by their screen name
			set offon [nozero [l0 $disp]]
			if [isempty 2] {print $nick "Current TWITTER USER DISPLAY status: [offon $offon]"; return 0}
			set 2 [string is true $2]

			sbdset TWITTER:DISP $2
			SB:botdatafile write
			print $nick "Twitter user display is now: [stu [offon $2]]"
			return 0
		}

		rate - ratelimit - stat - stats - status {
			set twhome [sbdget TWITTER:HOME]
			if [isempty twhome] {print $nick "You don't have a command channel set, you must set one to use this command."; return 0}
			if {[stl $chan] != [stl $twhome]} {print $nick "You cannot use this command in this channel, commands must be directed to ${twhome}"; return 0}

			# Use twitter:senddata process
			if {[catch {twitter:senddata $handle $nick $twitter::rate_limit_url {} GET} result]} {
				print $nick "Unable to retrieve your rate limit status. ($result)"
				return 0
			}

			if {[dict exists $result error]} {
				print $nick "Error: [dict get $result error]"
				return 0
			}

			set status [list $result]

			foreach stat $status {
				set remaining_hits [dict get $stat remaining_hits ]
				set hourly_limit [dict get $stat hourly_limit]
				set reset_time_sec [dict get $stat reset_time_in_seconds]

				if {$remaining_hits > 0} {
					print $nick "Status: All good, $remaining_hits/$hourly_limit requests left, Resets: [clock format $reset_time_sec -format "%l:%M %p"]"
					return 0
				} else {
					print $nick "Status: Rate limit exceeded, $remaining_hits/$hourly_limit requests left, Resets: [clock format $reset_time_sec -format "%l:%M %p"]"
					return 0
				}
			}
			return 0
		}

		shrtn - shorten {
			# URLs/Links have to be greater than this number to be reduced by the shortner setting.
			set twhome [sbdget TWITTER:HOME]
			if [isempty twhome] {print $nick "You don't have a command channel set, you must set one to use this command."; return 0}
			if {[stl $chan] != [stl $twhome]} {print $nick "You cannot use this command in this channel, commands must be directed to ${twhome}"; return 0}

			setdata $handle TWSHORTEN $2
			save
			print $nick "URLs/Links will now be shortened if greater than $2 characters."
			return 0
		}

		shrtnr - shortener {
			#Choice of URL/Link shortener
			# 0=is.gd, 1=moourl.com, 2=bit.ly, 3=cli.gs
			set twhome [sbdget TWITTER:HOME]
			if [isempty twhome] {print $nick "You don't have a command channel set, you must set one to use this command."; return 0}
			if {[stl $chan] != [stl $twhome]} {print $nick "You cannot use this command in this channel, commands must be directed to ${twhome}"; return 0}

			setdata $handle TWSHORTENER $2
			save

			if {$2 == 0} {print $nick "Your URL/Link shortener has been set to http://is.gd"; return 0}
			if {$2 == 1} {print $nick "Your URL/Link shortener has been set to http://moourl.com"; return 0}
			if {$2 == 2} {print $nick "Your URL/Link shortener has been set to http://bit.ly. Please set your bit.ly username and API key."; return 0}
			if {$2 == 3} {print $nick "Your URL/Link shortener has been set to http://cli.gs"; return 0}

			return 0
		}

		bun - bitlyun - bitlyusername {
			# User's bit.ly account username
			if $dccokay {
				if [sbd:equal -nocase @LAST_TRIGGER PUB] {printh $nick "You may not use this command in channel, for security purposes. Use either /MSG or .DCC to use this command."; return 0}
			} else {
				if ![sbd:equal -nocase @LAST_TRIGGER MSG] {printh $nick "You may only use this command in /MSG format for security purposes."; return 0}
			}

			setdata $handle BITLY-USERNAME $2
			save
			print $nick "Your bit.ly username has been saved."
			return 0
		}

		bapi - bitlyapi - bitlyapikey {
			# User's bit.ly account API key
			if $dccokay {
				if [sbd:equal -nocase @LAST_TRIGGER PUB] {printh $nick "You may not use this command in channel, for security purposes. Use either /MSG or .DCC to use this command."; return 0}
			} else {
				if ![sbd:equal -nocase @LAST_TRIGGER MSG] {printh $nick "You may only use this command in /MSG format for security purposes."; return 0}
			}

			setdata $handle BITLY-APIKEY $2
			save
			print $nick "Your bit.ly API Key has been saved."
			return 0
		}

		rtok - reqtok - reqtoken - requesttoken {
			set twhome [sbdget TWITTER:HOME]
			if [isempty twhome] {print $nick "You don't have a command channel set, you must set one to use this command."; return 0}
			if {[stl $chan] != [stl $twhome]} {print $nick "You cannot use this command in this channel, commands must be directed to ${twhome}"; return 0}

			if {[catch {oauth:get_request_token} data]} {
				print $nick "Error: $data"
				return 0
			}

			set url [dict get $data auth_url]
			print $nick "To get your authentication verifier, visit ${url} and allow the application on your Twiter account."
			print $nick "Once completed, use $::botnick TWITTER ACCTOKEN [dict get $data oauth_token] [dict get $data oauth_token_secret] <PIN from authorization URL of $::botnick TWITTER REQTOKEN>"
			return 0
		}

		atok - acctok - acctoken - accesstoken {
			set twhome [sbdget TWITTER:HOME]
			if [isempty twhome] {print $nick "You don't have a command channel set, you must set one to use this command."; return 0}
			if {[stl $chan] != [stl $twhome]} {print $nick "You cannot use this command in this channel, commands must be directed to ${twhome}"; return 0}

			if [string eq "" $2e] {print $nick "USAGE: $::botnick TWITTER ACCTOKEN <oauth token> <oauth token secret> <pin>"; return 0}

			set oauth_token $2
			set oauth_token_secret $3
			set pin $4

			if {[catch {oauth:get_access_token $oauth_token $oauth_token_secret $pin} data]} {
				print $nick "Error: $data"
				return 0
			}

			set twitter::oauth_token [dict get $data oauth_token]
			set twitter::oauth_token_secret [dict get $data oauth_token_secret]
			set screen_name [dict get $data screen_name]

			setdata $handle TWOAUTH "$twitter::oauth_token $twitter::oauth_token_secret $pin $screen_name"
			save

			print $nick "Successfully retrieved access token for ${screen_name}"
			return 0
		}

		profile {
			set twhome [sbdget TWITTER:HOME]
			if [isempty twhome] {print $nick "You don't have a command channel set, you must set one to use this command."; return 0}
			if {[stl $chan] != [stl $twhome]} {print $nick "You cannot use this command in this channel, commands must be directed to ${twhome}"; return 0}

			switch -exact -- $l2 {
				set {
					switch -exact -- $l3 {
						name {
							# Update the name on your profile
							# Use twitter:senddata process
							if {[catch {twitter:senddata $handle $nick $twitter::update_pro_url [list name $j4e]} result]} {
								print $nick "Unable to update the name on your profile, please try again."
								return 0
							}

							print $nick "Your name has now been set to $j4e"
							return 0
						}

						url {
							# Update the url on your profile
							# Use twitter:senddata process
							if {[catch {twitter:senddata $handle $nick $twitter::update_pro_url [list url $j4e]} result]} {
								print $nick "Unable to update your url, please try again."
								return 0
							}

							print $nick "Your url has now been set to $j4e"
							return 0
						}

						loc - location {
							# Update the location on your profile
							# Use twitter:senddata process
							if {[catch {twitter:senddata $handle $nick $twitter::update_pro_url [list location $j4e]} result]} {
								print $nick "Unable to update your location, please try again."
								return 0
							}

							print $nick "Your location has now been set to $j4e"
							return 0
						}

						desc - description {
							# Update the description on your profile
							# Use twitter:senddata process
							if {[catch {twitter:senddata $handle $nick $twitter::update_pro_url [list description $j4e]} result]} {
								print $nick "Unable to update your description, please try again."
								return 0
							}

							if {[len $j4] > 160} {
								print $nick "Please set a description less than 160 characters and try again."
								return 0
							} else {
								print $nick "Your description has now been set to $j4e"
								return 0
							}
							return 0
						}
					}
					return 0
				}

				view - show {
					set name $3

					# Use twitter:senddata process
					if {[catch {twitter:senddata $handle $nick $twitter::show_pro_url [list screen_name $name] GET} result]} {
						print $nick "Unable to retrieve profile for $name."
						return 0
					}

					set info [list $result]

					foreach profile $info {
						set id [dict get $profile id]
						set name [dict get $profile name]
						set sname [dict get $profile screen_name]
						set location [dict get $profile location]
						set desc [dict get $profile description]
						set url [dict get $profile url]
						set follow_count [dict get $profile followers_count]
						set status [dict get $profile status]
						set ltweet [dict get $status text]

						# Format time Sat May 26 12:45:00 +0000 2007 into an integer
						# converts it to Sat, May 26, 2007 @ 12:45 pm GMT
						# Taking in consideration for 8.4 backwards compatibility
						set created [clock format [clock scan [lreplace [split [dict get $profile created_at]] 4 4] -gmt true] -format "%a, %b %d, %Y @ %r %Z"]

						set fav_count [dict get $profile favourites_count]
						set friend_count [dict get $profile friends_count]
						set tzone [dict get $profile time_zone]
					}

					print $nick "\002${sname}'s Profile ($id)\002"
					print $nick "Screen Name: $sname"
					print $nick "Name: $name"
					print $nick "Location: $location"
					print $nick "Time Zone: $tzone"
					print $nick "URL: $url"
					print $nick "Description: $desc"
					print $nick "Counts - Friends: $friend_count, Followers: $follow_count, Favorites: $fav_count"
					print $nick "Last tweet: $ltweet"
					print $nick "Created: $created"
					return 0
				}
			}
			return 0
		}

		re - rt - retweet {
			# Retweet: BOT twitter (or tw) retweet (or rt) <id> to retweet a message
			set twhome [sbdget TWITTER:HOME]
			if [isempty twhome] {print $nick "You don't have a command channel set, you must set one to use this command."; return 0}
			if {[stl $chan] != [stl $twhome]} {print $nick "You cannot use this command in this channel, commands must be directed to ${twhome}"; return 0}

			# Use twitter:senddata process
			if {[catch {twitter:senddata $handle $nick "${twitter::retweet_url}${2}.json" {} POST} result]} {
				print $nick "Retweet failure! ($2) You can't retweet your own updates!"
				return 0
			}

			set retweets [list $result]
			foreach rtw $result {
				set id [dict get $rtw id]
				set text [dict get $rtw text]
			}
			print $nick "Your retweet has been submitted: $text (MSG ID: $id)"
			return 0
		}

		dm - direct {
			switch -glob -- $l2 {
				send {
					# Direct Message: BOT twitter (or tw) dm send <name> <msg> to direct message one of your followers
					set twhome [sbdget TWITTER:HOME]
					if [isempty twhome] {print $nick "You don't have a command channel set, you must set one to use this command."; return 0}
					if {[stl $chan] != [stl $twhome]} {print $nick "You cannot use this command in this channel, commands must be directed to ${twhome}"; return 0}

					set params [list screen_name $3 text [twitter:urlshorten $handle [twitter:replacetext $j4e]]]

					# Use twitter:senddata process
					if {[catch {twitter:senddata $handle $nick $twitter::dmsg_send_url $params} result]} {
						print $nick "Message to \002$3\002 failed! Are they following you?"
						return 0
					} elseif {[len $j3e] > 140} {
						set old_text $j4e
						set truncate 140
						set text [twitter:urlshorten $handle [twitter:replacetext $j4e]]

						print $nick "I've shortened this to a total of [len $text] characters, yet it's still too long. Use a service like http://www.twitlonger.com to submit this tweet, or send in multiple parts."
						print $nick "Submitted text: $old_text"
						print $nick "Shortened text: $text"
						print $nick "Snipped at: [mid $text [expr $truncate + 1] 40]"
						print $nick "Your direct message could not be sent to: $3"
						return 0
					} else {
						set direct [list $result]
						foreach dm $direct {
							set id [dict get $dm id]
						}
						print $nick "Your direct message has been sent to: $3 (MSG ID: $id)"
					}

					return 0
				}

				lst - list {
					# List your direct messages
					set twhome [sbdget TWITTER:HOME]
					if [isempty twhome] {print $nick "You don't have a command channel set, you must set one to use this command."; return 0}
					if {[stl $chan] != [stl $twhome]} {print $nick "You cannot use this command in this channel, commands must be directed to ${twhome}"; return 0}

					# Use twitter:senddata process
					if {[catch {twitter:senddata $handle $nick $twitter::dmsg_list_url} result]} {
						print $nick "Message retrieval failed."
						return 0
					}

					# Retrieve direct messages
					set msgs [lreverse $result]
					set x 0
					foreach msg $msgs {
						set id [dict get $msg id]
						set text [twitter:convert-unicode [SB:convert_html_codes [dict get $msg text]]]
						set sent [formattime [twitter:converttime [dict get $msg created_at]] $handle]
						set sender [dict get $msg sender_screen_name]
						set senderinfo [dict get $msg sender]
						set name [dict get $senderinfo name]

						print $nick "[incr x]. From $name ($sender) sent: $text ($sent)(Msg ID: $id)"
					}

					return 0
				}

				"-" - del* {
					# BOT twitter (or tw) dm del <msg id #> Delete Direct messages
					set twhome [sbdget TWITTER:HOME]
					if [isempty twhome] {print $nick "You don't have a command channel set, you must set one to use this command."; return 0}
					if {[stl $chan] != [stl $twhome]} {print $nick "You cannot use this command in this channel, commands must be directed to ${twhome}"; return 0}

					# Use twitter:senddata process
					if {[catch {twitter:senddata $handle $nick $twitter::dmsg_del_url [list id $3]} result]} {
						print $nick "Error! Message couldn't be deleted."
					}

					# Retrieve message for deletion
					set msg [list $result]
					foreach a $msg {
						set sendinfo [dict get $a sender]
						set sender [dict get $sendinfo name]
						set id [dict get $a id]
						set text [dict get $a text]

						print $nick "Deleted msg: $id \"$text\" sent from $sender"
					}

					return 0
				}
			}
			return 0
		}

		blk - block {
			# Block: BOT twitter (or tw) block <option> - to handle your block list
			switch -glob -- $l2 {
				+ - add {
					# Add someone to the block list
					set twhome [sbdget TWITTER:HOME]
					if [isempty twhome] {print $nick "You don't have a command channel set, you must set one to use this command."; return 0}
					if {[stl $chan] != [stl $twhome]} {print $nick "You cannot use this command in this channel, commands must be directed to ${twhome}"; return 0}

					# Use twitter:senddata process
					if {[catch {twitter:senddata $handle $nick $twitter::block_add_url [list screen_name $3]} result]} {
						print $nick "Unable to add $3 to block list."
						return 0
					}

					set nfo [list $result]
					foreach a $nfo {
						set id [dict get $a id]
						set sname [dict get $a screen_name]
					}

					print $nick "You are now blocking [stu $sname] ($id)"
					return 0
				}

				"-" - del* {
					# Remove someone from the block list
					set twhome [sbdget TWITTER:HOME]
					if [isempty twhome] {print $nick "You don't have a command channel set, you must set one to use this command."; return 0}
					if {[stl $chan] != [stl $twhome]} {print $nick "You cannot use this command in this channel, commands must be directed to ${twhome}"; return 0}

					# Use twitter:senddata process
					if {[catch {twitter:senddata $handle $nick $twitter::block_del_url [list screen_name $3]} result]} {
						print $nick "Unable to remove $3 from block list."
						return 0
					}

					set nfo [list $result]
					foreach a $nfo {
						set id [dict get $a id]
						set sname [dict get $a screen_name]
					}

					print $nick "You are now unblocking [stu $sname] ($id)"
					return 0
				}

				chk - check {
					# Check to see if someone is on the block list
					set twhome [sbdget TWITTER:HOME]
					if [isempty twhome] {print $nick "You don't have a command channel set, you must set one to use this command."; return 0}
					if {[stl $chan] != [stl $twhome]} {print $nick "You cannot use this command in this channel, commands must be directed to ${twhome}"; return 0}

					# Use twitter:senddata process
					if {[catch {twitter:senddata $handle $nick $twitter::block_chk_url [list screen_name $3] GET} result]} {
						print $nick "Unable to check your block list, please try again. ($result)"
						return 0
					}

					if {[dict exists $result error]} {
						print $nick "$result, $3."
					}

					set nfo [list $result]
					foreach a $nfo {
						set id [dict get $a id]
						set sname [dict get $a screen_name]
					}

					print $nick "You are currently blocking [stu $sname] ($id)"
					return 0
				}

				lst - list {
					# List your blocked users
					set twhome [sbdget TWITTER:HOME]
					if [isempty twhome] {print $nick "You don't have a command channel set, you must set one to use this command."; return 0}
					if {[stl $chan] != [stl $twhome]} {print $nick "You cannot use this command in this channel, commands must be directed to ${twhome}"; return 0}

					# Use twitter:senddata process
					if {[catch {twitter:senddata $handle $nick $twitter::block_list_url} result]} {
						print $nick "Unable to retrieve your block list."
						return 0
					}

					set nfo [lreverse $result]
					set x 0
					foreach a $nfo {
						set id [dict get $a id]
						set sname [dict get $a screen_name]
						set name [dict get $a name]

						print $nick "[incr x]. $sname ($name) - ID: $id"
					}
					return 0
				}
			}
			return 0
		}

		fr - friend - friends {
			# Friends: BOT twitter (or tw) friends  - to retrieve a friend's timeline
			set twhome [sbdget TWITTER:HOME]
			if [isempty twhome] {print $nick "You don't have a command channel set, you must set one to use this command."; return 0}
			if {[stl $chan] != [stl $twhome]} {print $nick "You cannot use this command in this channel, commands must be directed to ${twhome}"; return 0}

			set twfreply [getdata $handle since_freplies_id]
			if [isempty twfreply] { set twfreply 1 }

			# Use twitter:senddata process
			if {[catch {twitter:senddata $handle $nick $twitter::home_url [list since_reply $twfreply]} result]} {
				print $nick "Retrieval error. ($result)"
				return 0
			}

			set replies [lreverse $result]

			foreach reply $replies {
				set id [dict get $reply id]
				set user [dict get $reply user]
				set uname [dict get $user screen_name]
				set name [dict get $user name]

				set source [dict get $reply source]
				regexp -nocase -- {<a.+?>(.+?)</a>} $source all source

				set date [formattime [twitter:converttime [dict get $reply created_at]] $handle]

				set text [twitter:convert-unicode [SB:convert_html_codes [dict get $reply text]]]
				# Replace utf-8 entities that aren't covered by SB:convert_html_codes
				foreach {a b} [list \u2014 -- \u2019 ' \u2018 ' &#8212\\\; -- \u2013 -] {regsub -all $a $text $b text}

				if {[getdata $handle TWNAME] == $uname} {
					if {[sbdget TWITTER:DISP]} {
						print $nick "[color 13]\002$uname ($name)\002: $text (Posted: $date) via $source[color] (MSG ID: $id)"
					} else {
						print $nick "[color 13]\002$uname\002: $text (Posted: $date) via $source[color] (MSG ID: $id)"
					}
				} else {
					if {[sbdget TWITTER:DISP]} {
						print $nick "\002$uname ($name)\002: $text (Posted: $date) via $source (MSG ID: $id)"
					} else {
						print $nick "\002$uname\002: $text (Posted: $date) via $source (MSG ID: $id)"
					}
				}

				setdata $handle since_freplies_id $id
			}
			save
			return 0
		}

		rp - rpy - reply - men - mentions - replies { # Reply/Mentions code optimized for performance by Mai, thanks :)
			# Replies: BOT twitter (or tw) replies to retrieve your replies (@yourname) timeline
			set twhome [sbdget TWITTER:HOME]
			if [isempty twhome] {print $nick "You don't have a command channel set, you must set one to use this command."; return 0}
			if {[stl $chan] != [stl $twhome]} {print $nick "You cannot use this command in this channel, commands must be directed to ${twhome}"; return 0}

			set twreply [getdata $handle since_replies]
			if [isempty twreply] { set twreply 1 }

			# Use twitter:senddata process
			if {[catch {twitter:senddata $handle $nick $twitter::ment_url [list since_id $twreply]} result]} {
				print $nick "Unable to retrieve your mentions time line."
				return 0
			}

			set replies [lreverse $result]

			foreach reply $replies {
				set id [dict get $reply id]
				set user [dict get $reply user]
				set uname [dict get $user screen_name]
				set name [dict get $user name]

				set source [dict get $reply source]
				regexp -all -nocase -- {<a.+?>(.+?)</a>} $source all source

				set date [formattime [twitter:converttime [dict get $reply created_at]] $handle]

				set text [twitter:convert-unicode [SB:convert_html_codes [dict get $reply text]]]
				# Replace utf-8 entities that aren't covered by SB:convert_html_codes
				foreach {a b} [list \u2014 -- \u2019 ' \u2018 ' &#8212\\\; -- \u2013 -] {regsub -all $a $text $b text}

				if {[sbdget TWITTER:DISP]} {
					print $nick "\002$uname ($name)\002: $text (Posted: $date) via $source (MSG ID: $id)"
				} else {
					print $nick "\002$uname\002: $text (Posted: $date) via $source (MSG ID: $id)"
				}

				setdata $handle since_replies $id
			}
			save
			return 0
		}

		folow - follow {
			# Follow: BOT twitter (or tw) follow <name> to follow a user
			set twhome [sbdget TWITTER:HOME]
			if [isempty twhome] {print $nick "You don't have a command channel set, you must set one to use this command."; return 0}
			if {[stl $chan] != [stl $twhome]} { print $nick "You cannot use this command in this channel, commands must be directed to ${twhome}"; return 0}
			if [isempty l2] {print $nick "You must input a twitter account to follow."; return 0}

			# Use twitter:senddata process
			if {[catch {twitter:senddata $handle $nick $twitter::follow_url [list screen_name $l2]} result]} {
				return 0
			}

			if {[dict exists $result error]} {
				print $nick "Follow failed ($l2): [dict get $result error]"
				return 0
			}

			print $nick "You are now following: [color 8][stu $l2][color]"
			return 0
		}

		uf - unfolow - unfollow {
			# Unfollow: BOT twitter (or tw) unfollow <name> to unfollow a user
			set twhome [sbdget TWITTER:HOME]
			if [isempty twhome] {print $nick "You don't have a command channel set, you must set one to use this command."; return 0}
			if {[stl $chan] != [stl $twhome]} { print $nick "You cannot use this command in this channel, commands must be directed to ${twhome}"; return 0}
			if [isempty l2] {print $nick "You must input a twitter account to unfollow."; return 0}

			# Use twitter:senddata process
			if {[catch {twitter:senddata $handle $nick $twitter::unfollow_url [list screen_name $l2]} result]} {
				return 0
			}

			if {[dict exists $result error]} {
				print $nick "Unfollow failed ($l2): [dict get $result error]"
				return 0
			}

			print $nick "You are now unfollowing: [color 8][stu $l2][color]"
			return 0
		}

		trend - trending - trends {
			# Get the current top 10 trends
			# BOT twitter (or tw) trends
			set twhome [sbdget TWITTER:HOME]
			if [isempty twhome] {print $nick "You don't have a command channel set, you must set one to use this command."; return 0}
			if {[stl $chan] != [stl $twhome]} {print $nick "You cannot use this command in this channel, commands must be directed to ${twhome}"; return 0}

			# Use twitter:senddata process
			if {[catch {twitter:senddata $handle $nick $twitter::trends_url} result]} {
				print $nick "Trends fetch failed."
				return 0
			}

			set trending [list $result]

			foreach t $trending {
				set trends [dict get $t trends]

				# Format time Mon, 19 Oct 2009 07:50:48 +0000 into an integer 
				# converts it to Sat, May 26, 2007 @ 12:45 pm GMT
				# Taking in consideration for 8.4 backwards compatibility
				set asof [clock format [clock scan [lreplace [split [dict get $t as_of]] 5 5] -gmt true] -format "%a, %b %d, %Y @ %r %Z"]
				set x 0

				foreach a $trends {
					set name [dict get $a name]
					set url [dict get $a url]

					print $nick "[incr x]. $name - $url"
				}

				print $nick "Last update: $asof"
			}
			return 0
		}

		list - lists {
			# Manage your Twitter lists - Coming SOON
			switch -exact -- $l2 {
				create {
					# Create a list - accounts limited to 20 lists
					# http://api.twitter.com/1/user/lists.format
					return 0
				}

				update {
					# http://api.twitter.com/1/user/lists/id.format - id = name of list
					return 0
				}
			}
			return 0
		}

		su - search {
			# Search for users on Twitter
			# BOT twitter search <user>
			set twhome [sbdget TWITTER:HOME]
			if [isempty twhome] {print $nick "You don't have a command channel set, you must set one to use this command."; return 0}
			if {[stl $chan] != [stl $twhome]} {print $nick "You cannot use this command in this channel, commands must be directed to ${twhome}"; return 0}

			set user $2e
			regsub -all -nocase " " $user "%20" user

			set url ${twitter::search_usr_url}?[http::formatQuery q ${user} per_page 5]

			# Use twitter:senddata process
			if {[catch {twitter:senddata $handle $nick $url [list q ${user} per_page 5] GET} data]} {
				print $nick "Search error (${user}) - ($data)"
				return 0
			}

			if {[dict get $data error]} {
				print $nick "Search failed (${user}): [dict get $data error]"
				return 0
			}

			set result [lreverse $data]
			set x 0

			foreach u $result {
				set name [dict get $u name]
				set screen_name [dict get $u screen_name]
				set location [dict get $u location]
				set desc [dict get $u description]
				set follow [dict get $u following]
				set created [clock format [clock scan [lreplace [split [dict get $u created_at]] 4 4] -gmt true] -format "%a, %b %d, %Y @ %r %Z"]

				print $nick "[incr x]. \002$name ($screen_name)\002"
				print $nick "Description: $desc"
				print $nick "Location: $location"
				print $nick "Following: $follow"
				print $nick "Created: $created"
			}
			print $nick ">End Search"
			return 0
		}

		fav - favorite - favorites {
			# View your favoirted tweets
			# BOT twitter (or tw) favorites
			set twhome [sbdget TWITTER:HOME]
			if [isempty twhome] {print $nick "You don't have a command channel set, you must set one to use this command."; return 0}
			if {[stl $chan] != [stl $twhome]} {print $nick "You cannot use this command in this channel, commands must be directed to ${twhome}"; return 0}

			# Use twitter:senddata process
			if {[catch {twitter:senddata $handle $nick $twitter::fav_list_url} result]} {
				print $nick "Unable to retrieve your favorites list."
				return 0
			}

			set fav [lreverse $result]
			set x 0

			foreach f $fav {
				set user [dict get $f user]
				set uname [dict get $user screen_name]
				set name [dict get $user name]

				set source [dict get $f source]
				regexp -nocase -- {<a.+?>(.+?)</a>} $source all source

				set date [formattime [twitter:converttime [dict get $f created_at]] $handle]

				set text [twitter:convert-unicode [SB:convert_html_codes [dict get $f text]]]
				# Replace utf-8 entities that aren't covered by SB:convert_html_codes
				foreach {a b} [list \u2014 -- \u2019 ' \u2018 ' &#8212\\\; -- \u2013 -] {regsub -all $a $text $b text}

				if {[getdata $handle TWNAME] == $uname} {
					if {[sbdget TWITTER:DISP]} {
						print $nick "[incr x]. [color 13]$uname ($name): $text (Posted: $date) via $source[color]"
					} else {
						print $nick "[incr x]. [color 13]$uname: $text (Posted: $date) via $source[color]"
					}
				} else {
					if {[sbdget TWITTER:DISP]} {
						print $nick "[incr x]. $uname ($name): $text (Posted: $date) via $source"
					} else {
						print $nick "[incr x]. $uname: $text (Posted: $date) via $source"
					}
				}
			}
			print $nick ">End Favorites"
			return 0
		}

		"-" - del* {
			# Delete a tweet you've sent
			# BOT twitter delete <msg id>
			set twhome [sbdget TWITTER:HOME]
			if [isempty twhome] {print $nick "You don't have a command channel set, you must set one to use this command."; return 0}
			if {[stl $chan] != [stl $twhome]} {print $nick "You cannot use this command in this channel, commands must be directed to ${twhome}"; return 0}

			# Use twitter:senddata process
			if {[catch {twitter:senddata $handle $nick $twitter::status_del_url [list id $2]} result]} {
				print $nick "Unable to delete tweet (does it exist?)"
				return 0
			}

			# Retrieve tweet for deletion
			set tweet [list $result]
			foreach a $tweet {
				set text [dict get $a text]
				set id [dict get $a id]
				print $nick "Deleted tweet: \"$text\" (MSG ID: $id)"
			}
			return 0
		}

		default {
			# Default command option: to send a message
			# BOT twitter (or tw) <msg>
			set twhome [sbdget TWITTER:HOME]
			if [isempty twhome] {print $nick "You don't have a command channel set, you must set one to use this command."; return 0}
			if {[stl $chan] != [stl $twhome]} {print $nick "You cannot use this command in this channel, commands must be directed to ${twhome}"; return 0}

			# Use twitter:senddata process
			if {[catch {twitter:senddata $handle $nick $twitter::status_url [list status [twitter:urlshorten $handle [twitter:replacetext $j1e]]]} result]} {
				print $nick "Error: Unable to post tweet."
				return 0
			} elseif {[len $j1e] > 140} {
				set old_text $j1e
				set truncate 140
				set text [twitter:urlshorten $handle [twitter:replacetext $j1e]]

				print $nick "I've shortened this to a total of [len $text] characters, yet it's still too long. Use a service like http://www.twitlonger.com to submit this tweet, or send in multiple parts."
				print $nick "Submitted text: $old_text"
				print $nick "Shortened text: $text"
				print $nick "Snipped at: [mid $text [expr $truncate + 1] 40]"
				print $nick "Your tweet could not be submitted."
				return 0
			} else {
				set tweets [list $result]
				foreach tw $tweets {
					set id [dict get $tw id]
					set text [dict get $tw text]
				}
				print $nick "Your tweet has been submitted: $text (MSG ID: $id)"
				return 0
			}
			return 0
		}
	}
}

# Process to send data to Twitter
proc twitter:senddata { handle nick url {query_list {}} {http_method {}} } {
	# Set http method of query
	if {[isempty http_method] && [notempty query_list]} {
		set method POST
	} elseif {[isempty http_method] && [isempty query_list]} {
		set method GET
	} else {
		set method $http_method
	}
msghome TWITTER:METHOD($method)
msghome TWITTER:QUERY($query_list)
	set x [split [getdata $handle TWOAUTH]]
	set oauth_token [l0 $x]
	set oauth_token_secret [l1 $x]

	if {[isempty oauth_token] || [isempty oauth_token_secret]} {
		print $nick "Error: oAuth not initialized. Use $::botnick TWITTER REQTOKEN"
		return 0
	}

	set data [oauth:query_api $url $method $oauth_token $oauth_token_secret $query_list]
msghome TWITTER:DATA($data)
	return [json::json2dict $data]
}

# Work with URL shorteners
proc twitter:urlshorten {handle text} {
	set newtext ""
	foreach word [split $text] {
		if {[regexp {^www\.} $word] && ([string length $word] > [expr {[getdata $handle TWSHORTEN] + 6}])} {
			append newtext "[twitter:shorten $handle  "http://$word" [getdata $handle TWSHORTENER]] "
		} elseif {[regexp {^http\:} $word] && [string length $word] > [getdata $handle TWSHORTEN]} {
			append newtext "[twitter:shorten $handle $word [getdata $handle TWSHORTENER]] "
		} else {
			append newtext "$word "
		}
	}
	return [string trim $newtext]
}

# Shorten words to reduce text length
proc twitter:replacetext text {
	# Start a list of words to be shortened
	array set list ""
	set list(1) [list you U you're yr four 4 tomorrow 2morrow about abt to 2 two 2 because b/c with w/]
	set list(2) [list without w/out for 4 and \046 be B sorry sry this ths toady 2day why y text txt]
	set list(3) [list our R are R next nxt would wld like lk want wnt one 1 see C really rlly these ths]
	set list(4) [list won't wnt i've ive "bye for now" BFN background BG "best regards" BR "by the way" BTW]
	set list(5) [list "direct message" DM email EM facebook FB "face to face" FTF "for what it's worth" FWIW]
	set list(6) [list great Gr8 "in my opinion" IMO "in my honest opinion" IMHO "in my humble opinion" IMHO]
	set list(7) [list "in real life" IRL "just kidding" J/K LinkedIn LI "let me know" LMK "laughing my butt off" LMBO]
	set list(8) [list "laughin my ass off" LMAO "laughin out loud" LOL "no problem" NP "oh my god" OMG]
	set list(9) [list "oh my fucking god" OMFG please plz "rolling on the floor laughing" ROFL retweet RT]
	set list(10) [list "thanks for the retweet" RTHX "tweet me back" TMB "too much information" TMI]
	set list(11) [list "talk to you soon" TTYS "talk to you later" TTYL "thank you" TY "what the heck" WTH]
	set list(12) [list "what the hell" WTH "what the fuck" WTF "you're welcome" YW "you are welcome" YW]

	foreach x [lsort -int -inc [array names list]] {
		set item $list($x)
		foreach {find replace} $item {
			set text [ldestroy -all -nonulls -replace $text $find $replace]
		}
	}

	return $text
}

# Thanks again to Mai for writing this process. I would have had no idea on how to handle the unicode conversion.
proc twitter:convert-unicode { text { convert_to "utf-8"} } {
	set regexp [regexp -inline -all -- {\\u....} $text]
	# Tighter restraint?
	# set regexp [regexp -inline -all -nocase -- {\\u[0-9a-f]{4}} $text]
	foreach item $regexp {
		set item_split [split $item]
		set mid [mid $item 3];
		set dec [dec \$$mid];
		eval set char $item;
		regsub -all -- $item_split $text $char text
	}

	return [encoding convertto $convert_to $text]
}

# Another one by Mai ....
proc twitter:converttime date {
	if ![regexp -nocase -- {^[A-Z]{3} [A-Z]{3} \d\d \d\d:\d\d:\d\d [\+\-]\d{4} \d{4}$} $date] {return $date}
	lassign $date day month date time zone year
	#lassign [split $time :] hour monute second
	set timestamp [clock scan "$date $month $year $time"]
	set yourzone [nozero [left $zone 3][mantissa [ fixmath [ right $zone 2 ] / 60 ]]]
	set my [clock format [now] -format %z]
	set myzone [nozero [left $my 3][mantissa [ fixmath [ right $my 2 ] / 60 ]]]
	if [string compare $myzone $yourzone] {
		add timestamp [ fixmath ( $myzone - $yourzone ) * 3600 ]
		int timestamp
	}

	return $timestamp; # Adjusted so it'll print the time relative to YOUR timezone
}

proc twitter:shorten {handle url type} {
	# 0=is.gd, 1=moourl.com, 2=bit.ly, 3=cli.gs
	# moourl.com is unavalable until they release an api
	set agent "User Agent: Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US; rv:1.9.2.3) Gecko/20100401 Firefox/3.6.3 GTB7.0 ( .NET CLR 3.5.30729)"
	set www [::http::config -useragent $agent -urlencoding "utf-8"]

	switch -- $type {
		0 {set query "http://is.gd/api.php?[http::formatQuery longurl $url]"}
		1 {#set query "http://moourl.com/create/?[http::formatQuery source $url]"}
		2 {set query "http://api.bit.ly/v3/shorten?[http::formatQuery login [getdata $handle BITLY-USERNAME] apiKey [getdata $handle BITLY-APIKEY] longUrl $url format txt]"}
		3 {set query "http://cli.gs/api/v1/cligs/create?[http::formatQuery url $url]&title=&key=&appid=StormbotTCL"}
	}

	set token [http::geturl $query -timeout 10000]
	upvar #0 $token state
	if {![string match "* *" $state(body)]} { return [string map {"\n" ""} $state(body)] }
	return $url
}